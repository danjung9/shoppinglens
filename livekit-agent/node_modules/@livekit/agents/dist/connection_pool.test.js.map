{"version":3,"sources":["../src/connection_pool.test.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { describe, expect, it, vi } from 'vitest';\nimport { ConnectionPool } from './connection_pool.js';\n\ndescribe('ConnectionPool', () => {\n  const makeConnectCb = () => {\n    let n = 0;\n    return vi.fn(async (_timeout: number): Promise<string> => `conn_${++n}`);\n  };\n\n  describe('basic operations', () => {\n    it('should create and return a connection', async () => {\n      const connections: string[] = [];\n      const connectCb = vi.fn(async (_timeout: number): Promise<string> => {\n        const conn = `conn_${connections.length}`;\n        connections.push(conn);\n        return conn;\n      });\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      const conn = await pool.get();\n      expect(conn).toBe('conn_0');\n      expect(connectCb).toHaveBeenCalledTimes(1);\n\n      pool.put(conn);\n      const conn2 = await pool.get();\n      expect(conn2).toBe('conn_0'); // Should reuse\n      expect(connectCb).toHaveBeenCalledTimes(1);\n    });\n\n    it('should create new connection when none available', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      const conn1 = await pool.get();\n      pool.put(conn1);\n      const conn2 = await pool.get();\n      expect(conn1).toBe(conn2); // Should reuse\n      expect(connectCb).toHaveBeenCalledTimes(1);\n    });\n\n    it('should remove connection from pool', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      const conn = await pool.get();\n      pool.put(conn);\n      pool.remove(conn);\n\n      const conn2 = await pool.get();\n      expect(conn2).not.toBe(conn); // Should create new connection\n      expect(connectCb).toHaveBeenCalledTimes(2);\n      expect(closeCb).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('maxSessionDuration', () => {\n    it('should expire connections after maxSessionDuration', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n        maxSessionDuration: 100, // 100ms\n      });\n\n      const conn1 = await pool.get();\n      pool.put(conn1);\n\n      // Wait for expiration\n      await new Promise((resolve) => setTimeout(resolve, 150));\n\n      const conn2 = await pool.get();\n      expect(conn2).not.toBe(conn1); // Should create new connection\n      expect(connectCb).toHaveBeenCalledTimes(2);\n      expect(closeCb).toHaveBeenCalledTimes(1);\n    });\n\n    it('should refresh connection timestamp when markRefreshedOnGet is true', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n        maxSessionDuration: 200, // 200ms\n        markRefreshedOnGet: true,\n      });\n\n      const conn1 = await pool.get();\n      pool.put(conn1);\n\n      // Wait 100ms (less than expiration)\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      // Get again - should refresh timestamp\n      const conn2 = await pool.get();\n      expect(conn2).toBe(conn1); // Should reuse\n      pool.put(conn2);\n\n      // Wait another 100ms (total 200ms, but refreshed at 100ms)\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      // Should still be valid\n      const conn3 = await pool.get();\n      expect(conn3).toBe(conn1); // Should still reuse\n      expect(connectCb).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('withConnection', () => {\n    it('should return connection to pool on success', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      let capturedConn: string | undefined;\n      await pool.withConnection(async (conn) => {\n        capturedConn = conn;\n        return 'result';\n      });\n\n      // Connection should be returned to pool\n      const conn2 = await pool.get();\n      expect(conn2).toBe(capturedConn); // Should reuse\n      expect(connectCb).toHaveBeenCalledTimes(1);\n    });\n\n    it('should remove connection from pool on error', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      let capturedConn: string | undefined;\n      try {\n        await pool.withConnection(async (conn) => {\n          capturedConn = conn;\n          throw new Error('test error');\n        });\n      } catch (e) {\n        // Expected\n      }\n\n      // Connection should be removed from pool\n      const conn2 = await pool.get();\n      expect(conn2).not.toBe(capturedConn); // Should create new connection\n      expect(connectCb).toHaveBeenCalledTimes(2);\n      expect(closeCb).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle abort signal', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      const abortController = new AbortController();\n      let capturedConn: string | undefined;\n\n      const promise = pool.withConnection(\n        async (conn) => {\n          capturedConn = conn;\n          await new Promise((resolve) => setTimeout(resolve, 1000));\n          return 'result';\n        },\n        { signal: abortController.signal },\n      );\n\n      // Abort after a short delay\n      setTimeout(() => abortController.abort(), 10);\n\n      await expect(promise).rejects.toThrow();\n\n      // Connection should be removed from pool\n      const conn2 = await pool.get();\n      expect(conn2).not.toBe(capturedConn); // Should create new connection\n      expect(closeCb).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('prewarm', () => {\n    it('should create connection in background', async () => {\n      let n = 0;\n      const connectCb = vi.fn(async (_timeout: number): Promise<string> => {\n        await new Promise((resolve) => setTimeout(resolve, 50));\n        return `conn_${++n}`;\n      });\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      pool.prewarm();\n\n      // Wait for prewarm to complete\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      const conn = await pool.get();\n      expect(conn).toBeDefined();\n      expect(connectCb).toHaveBeenCalledTimes(1);\n    });\n\n    it('should not prewarm if connections already exist', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      // Create a connection first\n      const conn1 = await pool.get();\n      pool.put(conn1);\n\n      pool.prewarm(); // Should not create new connection\n\n      const conn2 = await pool.get();\n      expect(conn2).toBe(conn1); // Should reuse existing\n      expect(connectCb).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('close', () => {\n    it('should close all connections', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      // Create two distinct connections by checking out both before returning either.\n      const conn1 = await pool.get();\n      const conn2 = await pool.get();\n      pool.put(conn1);\n      pool.put(conn2);\n\n      await pool.close();\n\n      expect(closeCb).toHaveBeenCalledTimes(2);\n    });\n\n    it('should invalidate all connections', async () => {\n      const connectCb = makeConnectCb();\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      // Create two distinct connections by checking out both before returning either.\n      const conn1 = await pool.get();\n      const conn2 = await pool.get();\n      pool.put(conn1);\n      pool.put(conn2);\n\n      pool.invalidate();\n      await pool.close(); // Drain to close\n\n      expect(closeCb).toHaveBeenCalledTimes(2);\n    });\n  });\n\n  describe('concurrent access', () => {\n    it('should handle concurrent get requests', async () => {\n      const connectCb = vi.fn(async (_timeout: number): Promise<string> => {\n        await new Promise((resolve) => setTimeout(resolve, 10));\n        return `conn_${Date.now()}_${Math.random()}`;\n      });\n      const closeCb = vi.fn(async (_conn: string) => {\n        // Mock close\n      });\n\n      const pool = new ConnectionPool<string>({\n        connectCb,\n        closeCb,\n      });\n\n      const promises = Array.from({ length: 5 }, () => pool.get());\n      const connections = await Promise.all(promises);\n\n      // All should be different connections\n      const uniqueConnections = new Set(connections);\n      expect(uniqueConnections.size).toBe(5);\n      expect(connectCb).toHaveBeenCalledTimes(5);\n    });\n  });\n});\n"],"mappings":"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","names":["conn"]}