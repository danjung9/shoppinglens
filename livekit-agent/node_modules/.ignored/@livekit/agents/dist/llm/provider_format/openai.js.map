{"version":3,"sources":["../../../src/llm/provider_format/openai.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { ChatContext, ChatItem, ImageContent } from '../chat_context.js';\nimport { type SerializedImage, serializeImage } from '../utils.js';\nimport { groupToolCalls } from './utils.js';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function toChatCtx(chatCtx: ChatContext, injectDummyUserMessage: boolean = true) {\n  const itemGroups = groupToolCalls(chatCtx);\n  const messages: Record<string, any>[] = []; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  for (const group of itemGroups) {\n    if (group.isEmpty) continue;\n\n    const message: Record<string, any> = group.message // eslint-disable-line @typescript-eslint/no-explicit-any\n      ? await toChatItem(group.message)\n      : { role: 'assistant' };\n\n    const toolCalls = group.toolCalls.map((toolCall) => {\n      const tc: Record<string, any> = {\n        type: 'function',\n        id: toolCall.callId,\n        function: { name: toolCall.name, arguments: toolCall.args },\n      };\n\n      // Include provider-specific extra content (e.g., Google thought signatures)\n      const googleExtra = getGoogleExtra(toolCall);\n      if (googleExtra) {\n        tc.extra_content = { google: googleExtra };\n      }\n      return tc;\n    });\n\n    if (toolCalls.length > 0) {\n      message['tool_calls'] = toolCalls;\n    }\n\n    messages.push(message);\n\n    for (const toolOutput of group.toolOutputs) {\n      messages.push(await toChatItem(toolOutput));\n    }\n  }\n\n  return messages;\n}\n\nasync function toChatItem(item: ChatItem) {\n  if (item.type === 'message') {\n    const listContent: Record<string, any>[] = []; // eslint-disable-line @typescript-eslint/no-explicit-any\n    let textContent = '';\n\n    for (const content of item.content) {\n      if (typeof content === 'string') {\n        if (textContent) textContent += '\\n';\n        textContent += content;\n      } else if (content.type === 'image_content') {\n        listContent.push(await toImageContent(content));\n      } else {\n        throw new Error(`Unsupported content type: ${content.type}`);\n      }\n    }\n\n    const result: Record<string, any> = { role: item.role };\n    if (listContent.length === 0) {\n      result.content = textContent;\n    } else {\n      if (textContent.length > 0) {\n        listContent.push({ type: 'text', text: textContent });\n      }\n      result.content = listContent;\n    }\n\n    return result;\n  } else if (item.type === 'function_call') {\n    const tc: Record<string, any> = {\n      id: item.callId,\n      type: 'function',\n      function: { name: item.name, arguments: item.args },\n    };\n\n    // Include provider-specific extra content (e.g., Google thought signatures)\n    const googleExtra = getGoogleExtra(item);\n    if (googleExtra) {\n      tc.extra_content = { google: googleExtra };\n    }\n\n    return {\n      role: 'assistant',\n      tool_calls: [tc],\n    };\n  } else if (item.type === 'function_call_output') {\n    return {\n      role: 'tool',\n      tool_call_id: item.callId,\n      content: item.output,\n    };\n  }\n  // Skip other item types (e.g., agent_handoff)\n  // These should be filtered by groupToolCalls, but this is a safety net\n  throw new Error(`Unsupported item type: ${item['type']}`);\n}\n\nfunction getGoogleExtra(\n  item: Partial<{ extra?: Record<string, unknown>; thoughtSignature?: string }>,\n): Record<string, unknown> | undefined {\n  const googleExtra =\n    (item.extra?.google as Record<string, unknown> | undefined) ||\n    (item.thoughtSignature ? { thoughtSignature: item.thoughtSignature } : undefined);\n  return googleExtra;\n}\n\nasync function toImageContent(content: ImageContent) {\n  const cacheKey = 'serialized_image'; // TODO: use hash of encoding options if available\n  let serialized: SerializedImage;\n\n  if (content._cache[cacheKey] === undefined) {\n    serialized = await serializeImage(content);\n    content._cache[cacheKey] = serialized;\n  }\n  serialized = content._cache[cacheKey];\n\n  // Convert SerializedImage to OpenAI format\n  if (serialized.externalUrl) {\n    return {\n      type: 'image_url',\n      image_url: {\n        url: serialized.externalUrl,\n        detail: serialized.inferenceDetail,\n      },\n    };\n  }\n\n  if (serialized.base64Data === undefined) {\n    throw new Error('Serialized image has no data bytes');\n  }\n\n  return {\n    type: 'image_url',\n    image_url: {\n      url: `data:${serialized.mimeType};base64,${serialized.base64Data}`,\n      detail: serialized.inferenceDetail,\n    },\n  };\n}\n"],"mappings":"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","names":[]}