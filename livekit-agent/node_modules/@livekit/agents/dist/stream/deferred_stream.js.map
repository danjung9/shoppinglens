{"version":3,"sources":["../../src/stream/deferred_stream.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type {\n  ReadableStream,\n  ReadableStreamDefaultReader,\n  WritableStreamDefaultWriter,\n} from 'node:stream/web';\nimport { IdentityTransform } from './identity_transform.js';\n\n/**\n * Check if error is related to stream cleanup operations.\n *\n * These errors are expected when calling reader.read() after releaseLock()\n * or when writing to already closed streams during cleanup:\n *\n * Invalid state: Releasing reader\n * Invalid state: The reader is not attached to a stream\n * Invalid state: Controller is already closed\n * Invalid state: WritableStream is closed\n */\nexport function isStreamReaderReleaseError(e: unknown) {\n  const allowedMessages = [\n    'Invalid state: Releasing reader',\n    'Invalid state: The reader is not attached to a stream',\n    'Controller is already closed',\n    'WritableStream is closed',\n  ];\n\n  if (e instanceof TypeError) {\n    return allowedMessages.some((message) => e.message.includes(message));\n  }\n\n  return false;\n}\nexport class DeferredReadableStream<T> {\n  private transform: IdentityTransform<T>;\n  private writer: WritableStreamDefaultWriter<T>;\n  private sourceReader?: ReadableStreamDefaultReader<T>;\n\n  constructor() {\n    this.transform = new IdentityTransform<T>();\n    this.writer = this.transform.writable.getWriter();\n  }\n\n  get stream() {\n    return this.transform.readable;\n  }\n\n  get isSourceSet() {\n    return !!this.sourceReader;\n  }\n\n  /**\n   * Call once the actual source is ready.\n   */\n  setSource(source: ReadableStream<T>) {\n    if (this.isSourceSet) {\n      throw new Error('Stream source already set');\n    }\n\n    this.sourceReader = source.getReader();\n    this.pump();\n  }\n\n  private async pump() {\n    let sourceError: unknown;\n\n    try {\n      while (true) {\n        const { done, value } = await this.sourceReader!.read();\n        if (done) break;\n        await this.writer.write(value);\n      }\n    } catch (e) {\n      // skip stream cleanup related errors\n      if (isStreamReaderReleaseError(e)) return;\n\n      sourceError = e;\n    } finally {\n      // any other error from source will be propagated to the consumer\n      if (sourceError) {\n        try {\n          this.writer.abort(sourceError);\n        } catch (e) {\n          // ignore if writer is already closed\n        }\n        return;\n      }\n\n      // release lock so this.stream.getReader().read() will terminate with done: true\n      try {\n        this.writer.releaseLock();\n      } catch (e) {\n        // ignore if writer lock is already released\n      }\n\n      // we only close the writable stream after done\n      try {\n        await this.transform.writable.close();\n        // NOTE: we do not cancel this.transform.readable as there might be access to\n        // this.transform.readable.getReader() outside that blocks this cancellation\n        // hence, user is responsible for canceling reader on their own\n      } catch (e) {\n        // ignore TypeError: Invalid state: WritableStream is closed\n        // in case stream reader is already closed, this will throw\n        // but we ignore it as we are closing the stream anyway\n      }\n    }\n  }\n\n  /**\n   * Detach the source stream and clean up resources.\n   */\n  async detachSource() {\n    if (!this.isSourceSet) {\n      // No-op if source was never set - this is a common case during cleanup\n      return;\n    }\n\n    // release lock will make any pending read() throw TypeError\n    // which are expected, and we intentionally catch those error\n    // using isStreamReaderReleaseError\n    // this will unblock any pending read() inside the async for loop\n    this.sourceReader!.releaseLock();\n  }\n}\n"],"mappings":"AAQA,SAAS,yBAAyB;AAa3B,SAAS,2BAA2B,GAAY;AACrD,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,aAAa,WAAW;AAC1B,WAAO,gBAAgB,KAAK,CAAC,YAAY,EAAE,QAAQ,SAAS,OAAO,CAAC;AAAA,EACtE;AAEA,SAAO;AACT;AACO,MAAM,uBAA0B;AAAA,EAC7B;AAAA,EACA;AAAA,EACA;AAAA,EAER,cAAc;AACZ,SAAK,YAAY,IAAI,kBAAqB;AAC1C,SAAK,SAAS,KAAK,UAAU,SAAS,UAAU;AAAA,EAClD;AAAA,EAEA,IAAI,SAAS;AACX,WAAO,KAAK,UAAU;AAAA,EACxB;AAAA,EAEA,IAAI,cAAc;AAChB,WAAO,CAAC,CAAC,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,QAA2B;AACnC,QAAI,KAAK,aAAa;AACpB,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AAEA,SAAK,eAAe,OAAO,UAAU;AACrC,SAAK,KAAK;AAAA,EACZ;AAAA,EAEA,MAAc,OAAO;AACnB,QAAI;AAEJ,QAAI;AACF,aAAO,MAAM;AACX,cAAM,EAAE,MAAM,MAAM,IAAI,MAAM,KAAK,aAAc,KAAK;AACtD,YAAI,KAAM;AACV,cAAM,KAAK,OAAO,MAAM,KAAK;AAAA,MAC/B;AAAA,IACF,SAAS,GAAG;AAEV,UAAI,2BAA2B,CAAC,EAAG;AAEnC,oBAAc;AAAA,IAChB,UAAE;AAEA,UAAI,aAAa;AACf,YAAI;AACF,eAAK,OAAO,MAAM,WAAW;AAAA,QAC/B,SAAS,GAAG;AAAA,QAEZ;AACA;AAAA,MACF;AAGA,UAAI;AACF,aAAK,OAAO,YAAY;AAAA,MAC1B,SAAS,GAAG;AAAA,MAEZ;AAGA,UAAI;AACF,cAAM,KAAK,UAAU,SAAS,MAAM;AAAA,MAItC,SAAS,GAAG;AAAA,MAIZ;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe;AACnB,QAAI,CAAC,KAAK,aAAa;AAErB;AAAA,IACF;AAMA,SAAK,aAAc,YAAY;AAAA,EACjC;AACF;","names":[]}