/**
 * Helper class to manage persistent connections like websockets.
 */
export interface ConnectionPoolOptions<T> {
    /**
     * Maximum duration in milliseconds before forcing reconnection.
     * If not set, connections will never expire based on duration.
     */
    maxSessionDuration?: number;
    /**
     * If true, the session will be marked as fresh when get() is called.
     * Only used when maxSessionDuration is set.
     */
    markRefreshedOnGet?: boolean;
    /**
     * Async callback to create new connections.
     * @param timeout - Connection timeout in milliseconds
     * @returns A new connection object
     */
    connectCb: (timeout: number) => Promise<T>;
    /**
     * Optional async callback to close connections.
     * @param conn - The connection to close
     */
    closeCb?: (conn: T) => Promise<void>;
    /**
     * Default connection timeout in milliseconds.
     * Defaults to 10000 (10 seconds).
     */
    connectTimeout?: number;
}
/**
 * Connection pool for managing persistent WebSocket connections.
 *
 * Reuses connections efficiently and automatically refreshes them after max duration.
 * Prevents creating too many connections in a single conversation.
 */
export declare class ConnectionPool<T> {
    private readonly maxSessionDuration?;
    private readonly markRefreshedOnGet;
    private readonly connectCb;
    private readonly closeCb?;
    private readonly connectTimeout;
    private readonly connections;
    private readonly available;
    private readonly toClose;
    private readonly connectLock;
    private prewarmController?;
    constructor(options: ConnectionPoolOptions<T>);
    /**
     * Create a new connection.
     *
     * @param timeout - Connection timeout in milliseconds
     * @returns The new connection object
     * @throws If connectCb is not provided or connection fails
     */
    private _connect;
    /**
     * Drain and close all connections queued for closing.
     */
    private _drainToClose;
    /**
     * Close a connection if closeCb is provided.
     *
     * @param conn - The connection to close
     */
    private _maybeCloseConnection;
    private _abortError;
    /**
     * Get an available connection or create a new one if needed.
     *
     * @param timeout - Connection timeout in milliseconds
     * @returns An active connection object
     */
    get(timeout?: number): Promise<T>;
    /**
     * Mark a connection as available for reuse.
     *
     * If connection has been removed, it will not be added to the pool.
     *
     * @param conn - The connection to make available
     */
    put(conn: T): void;
    /**
     * Remove a specific connection from the pool.
     *
     * Marks the connection to be closed during the next drain cycle.
     *
     * @param conn - The connection to remove
     */
    remove(conn: T): void;
    /**
     * Clear all existing connections.
     *
     * Marks all current connections to be closed during the next drain cycle.
     */
    invalidate(): void;
    /**
     * Initiate prewarming of the connection pool without blocking.
     *
     * This method starts a background task that creates a new connection if none exist.
     * The task automatically cleans itself up when the connection pool is closed.
     */
    prewarm(): void;
    private _prewarmImpl;
    /**
     * Get a connection from the pool and automatically return it when done.
     * Handles abort signals and ensures proper cleanup.
     *
     * @param fn - Function to execute with the connection
     * @param options - Options including timeout and abort signal
     * @returns The result of the function
     */
    withConnection<R>(fn: (conn: T) => Promise<R>, options?: {
        timeout?: number;
        signal?: AbortSignal;
    }): Promise<R>;
    /**
     * Close all connections, draining any pending connection closures.
     */
    close(): Promise<void>;
}
//# sourceMappingURL=connection_pool.d.ts.map