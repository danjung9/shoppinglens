"use strict";
var import_vitest = require("vitest");
var import_exceptions = require("../_exceptions.cjs");
var import_log = require("../log.cjs");
var import_utils = require("../utils.cjs");
var import_fallback_adapter = require("./fallback_adapter.cjs");
var import_llm = require("./llm.cjs");
class MockLLMStream extends import_llm.LLMStream {
  constructor(llm, opts, shouldFail = false, failAfterChunks = 0) {
    super(llm, opts);
    this.shouldFail = shouldFail;
    this.failAfterChunks = failAfterChunks;
    this.myLLM = llm;
  }
  myLLM;
  async run() {
    if (this.shouldFail && this.failAfterChunks === 0) {
      throw new import_exceptions.APIError("Mock LLM failed immediately");
    }
    const chunk = {
      id: "test-id",
      delta: { role: "assistant", content: "chunk" }
    };
    for (let i = 0; i < 3; i++) {
      if (this.shouldFail && i === this.failAfterChunks) {
        throw new import_exceptions.APIError("Mock LLM failed after chunks");
      }
      this.queue.put(chunk);
      await (0, import_utils.delay)(10);
    }
  }
}
class MockLLM extends import_llm.LLM {
  shouldFail = false;
  failAfterChunks = 0;
  _label;
  constructor(label) {
    super();
    this._label = label;
  }
  label() {
    return this._label;
  }
  chat(opts) {
    return new MockLLMStream(
      this,
      {
        chatCtx: opts.chatCtx,
        toolCtx: opts.toolCtx,
        connOptions: opts.connOptions
      },
      this.shouldFail,
      this.failAfterChunks
    );
  }
}
(0, import_vitest.describe)("FallbackAdapter", () => {
  (0, import_vitest.beforeAll)(() => {
    (0, import_log.initializeLogger)({ pretty: false });
    process.on("unhandledRejection", () => {
    });
  });
  (0, import_vitest.it)("should initialize correctly", () => {
    const llm1 = new MockLLM("llm1");
    const adapter = new import_fallback_adapter.FallbackAdapter({ llms: [llm1] });
    (0, import_vitest.expect)(adapter.llms).toHaveLength(1);
    (0, import_vitest.expect)(adapter.llms[0]).toBe(llm1);
  });
  (0, import_vitest.it)("should throw if no LLMs provided", () => {
    (0, import_vitest.expect)(() => new import_fallback_adapter.FallbackAdapter({ llms: [] })).toThrow();
  });
  (0, import_vitest.it)("should use primary LLM if successful", async () => {
    const llm1 = new MockLLM("llm1");
    const llm2 = new MockLLM("llm2");
    const adapter = new import_fallback_adapter.FallbackAdapter({ llms: [llm1, llm2] });
    const stream = adapter.chat({
      chatCtx: {}
    });
    const chunks = [];
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    (0, import_vitest.expect)(chunks).toHaveLength(3);
  });
  (0, import_vitest.it)("should fallback to second LLM if first fails immediately", async () => {
    const llm1 = new MockLLM("llm1");
    llm1.shouldFail = true;
    const llm2 = new MockLLM("llm2");
    const adapter = new import_fallback_adapter.FallbackAdapter({ llms: [llm1, llm2] });
    const stream = adapter.chat({
      chatCtx: {}
    });
    const chunks = [];
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    (0, import_vitest.expect)(chunks).toHaveLength(3);
    (0, import_vitest.expect)(adapter._status[0].available).toBe(false);
    (0, import_vitest.expect)(adapter._status[1].available).toBe(true);
  });
  (0, import_vitest.it)("should fail if all LLMs fail", async () => {
    const llm1 = new MockLLM("llm1");
    llm1.shouldFail = true;
    const llm2 = new MockLLM("llm2");
    llm2.shouldFail = true;
    const adapter = new import_fallback_adapter.FallbackAdapter({ llms: [llm1, llm2] });
    const stream = adapter.chat({
      chatCtx: {}
    });
    const errorPromise = new Promise((resolve) => {
      adapter.on("error", (e) => resolve(e.error));
    });
    for await (const _ of stream) {
    }
    const error = await errorPromise;
    (0, import_vitest.expect)(error).toBeInstanceOf(import_exceptions.APIConnectionError);
  });
  (0, import_vitest.it)("should fail if chunks sent and retryOnChunkSent is false", async () => {
    const llm1 = new MockLLM("llm1");
    llm1.shouldFail = true;
    llm1.failAfterChunks = 1;
    const llm2 = new MockLLM("llm2");
    const adapter = new import_fallback_adapter.FallbackAdapter({
      llms: [llm1, llm2],
      retryOnChunkSent: false
    });
    const stream = adapter.chat({
      chatCtx: {}
    });
    const errorPromise = new Promise((resolve) => {
      adapter.on("error", (e) => resolve(e.error));
    });
    for await (const _ of stream) {
    }
    const error = await errorPromise;
    (0, import_vitest.expect)(error).toBeInstanceOf(import_exceptions.APIError);
  });
  (0, import_vitest.it)("should fallback if chunks sent and retryOnChunkSent is true", async () => {
    const llm1 = new MockLLM("llm1");
    llm1.shouldFail = true;
    llm1.failAfterChunks = 1;
    const llm2 = new MockLLM("llm2");
    const adapter = new import_fallback_adapter.FallbackAdapter({
      llms: [llm1, llm2],
      retryOnChunkSent: true
    });
    const stream = adapter.chat({
      chatCtx: {}
    });
    const chunks = [];
    for await (const chunk of stream) {
      chunks.push(chunk);
    }
    (0, import_vitest.expect)(chunks).toHaveLength(4);
  });
  (0, import_vitest.it)("should emit availability changed events", async () => {
    const llm1 = new MockLLM("llm1");
    llm1.shouldFail = true;
    const llm2 = new MockLLM("llm2");
    const adapter = new import_fallback_adapter.FallbackAdapter({ llms: [llm1, llm2] });
    const eventSpy = import_vitest.vi.fn();
    adapter.on("llm_availability_changed", eventSpy);
    const stream = adapter.chat({
      chatCtx: {}
    });
    for await (const _ of stream) {
    }
    (0, import_vitest.expect)(eventSpy).toHaveBeenCalledWith(
      import_vitest.expect.objectContaining({
        llm: llm1,
        available: false
      })
    );
  });
});
//# sourceMappingURL=fallback_adapter.test.cjs.map