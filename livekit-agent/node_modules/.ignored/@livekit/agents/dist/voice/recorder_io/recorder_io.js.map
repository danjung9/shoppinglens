{"version":3,"sources":["../../../src/voice/recorder_io/recorder_io.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport ffmpegInstaller from '@ffmpeg-installer/ffmpeg';\nimport { Mutex } from '@livekit/mutex';\nimport { AudioFrame, AudioResampler } from '@livekit/rtc-node';\nimport ffmpeg from 'fluent-ffmpeg';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { PassThrough } from 'node:stream';\nimport type { ReadableStream } from 'node:stream/web';\nimport { TransformStream } from 'node:stream/web';\nimport { log } from '../../log.js';\nimport { isStreamReaderReleaseError } from '../../stream/deferred_stream.js';\nimport { type StreamChannel, createStreamChannel } from '../../stream/stream_channel.js';\nimport { Future, Task, cancelAndWait, delay } from '../../utils.js';\nimport type { AgentSession } from '../agent_session.js';\nimport { AudioInput, AudioOutput, type PlaybackFinishedEvent } from '../io.js';\n\nffmpeg.setFfmpegPath(ffmpegInstaller.path);\n\nconst WRITE_INTERVAL_MS = 2500;\nconst DEFAULT_SAMPLE_RATE = 48000;\n\nexport interface RecorderOptions {\n  agentSession: AgentSession;\n  sampleRate?: number;\n}\n\ninterface ResampleAndMixOptions {\n  frames: AudioFrame[];\n  resampler: AudioResampler | undefined;\n  flush?: boolean;\n}\n\nexport class RecorderIO {\n  private inRecord?: RecorderAudioInput;\n  private outRecord?: RecorderAudioOutput;\n\n  private inChan: StreamChannel<AudioFrame[]> = createStreamChannel<AudioFrame[]>();\n  private outChan: StreamChannel<AudioFrame[]> = createStreamChannel<AudioFrame[]>();\n\n  private session: AgentSession;\n  private sampleRate: number;\n\n  private _outputPath?: string;\n  private forwardTask?: Task<void>;\n  private encodeTask?: Task<void>;\n\n  private closeFuture: Future<void> = new Future();\n  private lock: Mutex = new Mutex();\n  private started: boolean = false;\n\n  // FFmpeg streaming state\n  private pcmStream?: PassThrough;\n  private ffmpegPromise?: Promise<void>;\n  private inResampler?: AudioResampler;\n  private outResampler?: AudioResampler;\n\n  private logger = log();\n\n  constructor(opts: RecorderOptions) {\n    const { agentSession, sampleRate = DEFAULT_SAMPLE_RATE } = opts;\n\n    this.session = agentSession;\n    this.sampleRate = sampleRate;\n  }\n\n  async start(outputPath: string): Promise<void> {\n    const unlock = await this.lock.lock();\n\n    try {\n      if (this.started) return;\n\n      if (!this.inRecord || !this.outRecord) {\n        throw new Error(\n          'RecorderIO not properly initialized: both `recordInput()` and `recordOutput()` must be called before starting the recorder.',\n        );\n      }\n\n      this._outputPath = outputPath;\n      this.started = true;\n      this.closeFuture = new Future();\n\n      // Ensure output directory exists\n      const dir = path.dirname(outputPath);\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n\n      this.forwardTask = Task.from(({ signal }) => this.forward(signal));\n      this.encodeTask = Task.from(() => this.encode(), undefined, 'recorder_io_encode_task');\n    } finally {\n      unlock();\n    }\n  }\n\n  async close(): Promise<void> {\n    const unlock = await this.lock.lock();\n\n    try {\n      if (!this.started) return;\n\n      await this.inChan.close();\n      await this.outChan.close();\n      await this.closeFuture.await;\n      await cancelAndWait([this.forwardTask!, this.encodeTask!]);\n\n      this.started = false;\n    } finally {\n      unlock();\n    }\n  }\n\n  recordInput(audioInput: AudioInput): RecorderAudioInput {\n    this.inRecord = new RecorderAudioInput(this, audioInput);\n    return this.inRecord;\n  }\n\n  recordOutput(audioOutput: AudioOutput): RecorderAudioOutput {\n    this.outRecord = new RecorderAudioOutput(this, audioOutput, (buf) => this.writeCb(buf));\n    return this.outRecord;\n  }\n\n  private writeCb(buf: AudioFrame[]): void {\n    const inputBuf = this.inRecord!.takeBuf();\n    this.inChan.write(inputBuf);\n    this.outChan.write(buf);\n  }\n\n  get recording(): boolean {\n    return this.started;\n  }\n\n  get outputPath(): string | undefined {\n    return this._outputPath;\n  }\n\n  get recordingStartedAt(): number | undefined {\n    // Use session start time to align with trace timestamps\n    return this.session._startedAt;\n  }\n\n  /**\n   * Forward task: periodically flush input buffer to encoder\n   */\n  private async forward(signal: AbortSignal): Promise<void> {\n    while (!signal.aborted) {\n      try {\n        await delay(WRITE_INTERVAL_MS, { signal });\n      } catch {\n        // Aborted\n        break;\n      }\n\n      if (this.outRecord!.hasPendingData) {\n        // If the output is currently playing audio, wait for it to stay in sync\n        continue;\n      }\n\n      // Flush input buffer\n      const inputBuf = this.inRecord!.takeBuf();\n      this.inChan\n        .write(inputBuf)\n        .catch((err) => this.logger.error({ err }, 'Error writing RecorderIO input buffer'));\n      this.outChan\n        .write([])\n        .catch((err) => this.logger.error({ err }, 'Error writing RecorderIO output buffer'));\n    }\n  }\n\n  /**\n   * Start FFmpeg process for streaming encoding\n   */\n  private startFFmpeg(): void {\n    if (this.pcmStream) return;\n\n    this.pcmStream = new PassThrough();\n\n    this.ffmpegPromise = new Promise<void>((resolve, reject) => {\n      ffmpeg(this.pcmStream!)\n        .inputFormat('s16le')\n        .inputOptions([`-ar ${this.sampleRate}`, '-ac 2'])\n        .audioCodec('libopus')\n        .audioChannels(2)\n        .audioFrequency(this.sampleRate)\n        .format('ogg')\n        .output(this._outputPath!)\n        .on('end', () => {\n          this.logger.debug('FFmpeg encoding finished');\n          resolve();\n        })\n        .on('error', (err) => {\n          // Ignore errors from intentional stream closure or SIGINT during shutdown\n          if (\n            err.message?.includes('Output stream closed') ||\n            err.message?.includes('received signal 2') ||\n            err.message?.includes('SIGKILL') ||\n            err.message?.includes('SIGINT')\n          ) {\n            resolve();\n          } else {\n            this.logger.error({ err }, 'FFmpeg encoding error');\n            reject(err);\n          }\n        })\n        .run();\n    });\n  }\n\n  /**\n   * Resample and mix frames to mono Float32\n   */\n  private resampleAndMix(opts: ResampleAndMixOptions): {\n    samples: Float32Array;\n    resampler: AudioResampler | undefined;\n  } {\n    const INV_INT16 = 1.0 / 32768.0;\n    const { frames, flush = false } = opts;\n    let { resampler } = opts;\n\n    if (frames.length === 0 && !flush) {\n      return { samples: new Float32Array(0), resampler };\n    }\n\n    if (!resampler && frames.length > 0) {\n      const firstFrame = frames[0]!;\n      resampler = new AudioResampler(firstFrame.sampleRate, this.sampleRate, firstFrame.channels);\n    }\n\n    const resampledFrames: AudioFrame[] = [];\n    for (const frame of frames) {\n      if (resampler) {\n        resampledFrames.push(...resampler.push(frame));\n      }\n    }\n\n    if (flush && resampler) {\n      resampledFrames.push(...resampler.flush());\n    }\n\n    const totalSamples = resampledFrames.reduce((acc, frame) => acc + frame.samplesPerChannel, 0);\n    const samples = new Float32Array(totalSamples);\n\n    let pos = 0;\n    for (const frame of resampledFrames) {\n      const data = frame.data;\n      const numChannels = frame.channels;\n      for (let i = 0; i < frame.samplesPerChannel; i++) {\n        let sum = 0;\n        for (let ch = 0; ch < numChannels; ch++) {\n          sum += data[i * numChannels + ch]!;\n        }\n        samples[pos++] = (sum / numChannels) * INV_INT16;\n      }\n    }\n\n    return { samples, resampler };\n  }\n\n  /**\n   * Write PCM chunk to FFmpeg stream\n   */\n  private writePCM(leftSamples: Float32Array, rightSamples: Float32Array): void {\n    if (!this.pcmStream) {\n      this.startFFmpeg();\n    }\n\n    // Handle length mismatch by prepending silence\n    if (leftSamples.length !== rightSamples.length) {\n      const diff = Math.abs(leftSamples.length - rightSamples.length);\n      if (leftSamples.length < rightSamples.length) {\n        this.logger.warn(\n          `Input is shorter by ${diff} samples; silence has been prepended to align the input channel.`,\n        );\n        const padded = new Float32Array(rightSamples.length);\n        padded.set(leftSamples, diff);\n        leftSamples = padded;\n      } else {\n        const padded = new Float32Array(leftSamples.length);\n        padded.set(rightSamples, diff);\n        rightSamples = padded;\n      }\n    }\n\n    const maxLen = Math.max(leftSamples.length, rightSamples.length);\n    if (maxLen <= 0) return;\n\n    // Interleave stereo samples and convert back to Int16\n    const stereoData = new Int16Array(maxLen * 2);\n    for (let i = 0; i < maxLen; i++) {\n      stereoData[i * 2] = Math.max(\n        -32768,\n        Math.min(32767, Math.round((leftSamples[i] ?? 0) * 32768)),\n      );\n      stereoData[i * 2 + 1] = Math.max(\n        -32768,\n        Math.min(32767, Math.round((rightSamples[i] ?? 0) * 32768)),\n      );\n    }\n\n    this.pcmStream!.write(Buffer.from(stereoData.buffer));\n  }\n\n  /**\n   * Encode task: read from channels, mix to stereo, stream to FFmpeg\n   */\n  private async encode(): Promise<void> {\n    if (!this._outputPath) return;\n\n    const inReader = this.inChan.stream().getReader();\n    const outReader = this.outChan.stream().getReader();\n\n    try {\n      while (true) {\n        const [inResult, outResult] = await Promise.all([inReader.read(), outReader.read()]);\n\n        if (inResult.done || outResult.done) {\n          break;\n        }\n\n        const inputBuf = inResult.value;\n        const outputBuf = outResult.value;\n\n        const inMixed = this.resampleAndMix({ frames: inputBuf, resampler: this.inResampler });\n        this.inResampler = inMixed.resampler;\n\n        const outMixed = this.resampleAndMix({\n          frames: outputBuf,\n          resampler: this.outResampler,\n          flush: outputBuf.length > 0,\n        });\n        this.outResampler = outMixed.resampler;\n\n        // Stream PCM data directly to FFmpeg\n        this.writePCM(inMixed.samples, outMixed.samples);\n      }\n\n      // Close FFmpeg stream and wait for encoding to complete\n      if (this.pcmStream) {\n        this.pcmStream.end();\n        await this.ffmpegPromise;\n      }\n    } catch (err) {\n      this.logger.error({ err }, 'Error in encode task');\n    } finally {\n      inReader.releaseLock();\n      outReader.releaseLock();\n\n      if (!this.closeFuture.done) {\n        this.closeFuture.resolve();\n      }\n    }\n  }\n}\n\nclass RecorderAudioInput extends AudioInput {\n  private source: AudioInput;\n  private recorderIO: RecorderIO;\n  private accFrames: AudioFrame[] = [];\n  private _startedWallTime?: number;\n\n  constructor(recorderIO: RecorderIO, source: AudioInput) {\n    super();\n    this.recorderIO = recorderIO;\n    this.source = source;\n\n    // Set up the intercepting stream\n    this.deferredStream.setSource(this.createInterceptingStream());\n  }\n\n  /**\n   * Wall-clock time when the first frame was captured\n   */\n  get startedWallTime(): number | undefined {\n    return this._startedWallTime;\n  }\n\n  /**\n   * Take accumulated frames and clear the buffer\n   */\n  takeBuf(): AudioFrame[] {\n    const frames = this.accFrames;\n    this.accFrames = [];\n    return frames;\n  }\n\n  /**\n   * Creates a stream that intercepts frames from the source,\n   * accumulates them when recording, and passes them through unchanged.\n   */\n  private createInterceptingStream(): ReadableStream<AudioFrame> {\n    const sourceStream = this.source.stream;\n    const reader = sourceStream.getReader();\n\n    const transform = new TransformStream<AudioFrame, AudioFrame>({\n      transform: (frame, controller) => {\n        // Accumulate frames when recording is active\n        if (this.recorderIO.recording) {\n          if (this._startedWallTime === undefined) {\n            this._startedWallTime = Date.now();\n          }\n          this.accFrames.push(frame);\n        }\n\n        controller.enqueue(frame);\n      },\n    });\n\n    const pump = async () => {\n      const writer = transform.writable.getWriter();\n      let sourceError: unknown;\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          await writer.write(value);\n        }\n      } catch (e) {\n        if (isStreamReaderReleaseError(e)) return;\n        sourceError = e;\n      } finally {\n        if (sourceError) {\n          writer.abort(sourceError);\n          return;\n        }\n\n        writer.releaseLock();\n\n        try {\n          await transform.writable.close();\n        } catch {\n          // ignore \"WritableStream is closed\" errors\n        }\n      }\n    };\n\n    pump();\n\n    return transform.readable;\n  }\n\n  onAttached(): void {\n    this.source.onAttached();\n  }\n\n  onDetached(): void {\n    this.source.onDetached();\n  }\n}\n\nclass RecorderAudioOutput extends AudioOutput {\n  private recorderIO: RecorderIO;\n  private writeFn: (buf: AudioFrame[]) => void;\n  private accFrames: AudioFrame[] = [];\n  private _startedWallTime?: number;\n\n  // Pause tracking\n  private currentPauseStart?: number;\n  private pauseWallTimes: Array<[number, number]> = []; // [start, end] pairs\n\n  constructor(\n    recorderIO: RecorderIO,\n    audioOutput: AudioOutput,\n    writeFn: (buf: AudioFrame[]) => void,\n  ) {\n    super(audioOutput.sampleRate, audioOutput, { pause: true });\n    this.recorderIO = recorderIO;\n    this.writeFn = writeFn;\n  }\n\n  get startedWallTime(): number | undefined {\n    return this._startedWallTime;\n  }\n\n  get hasPendingData(): boolean {\n    return this.accFrames.length > 0;\n  }\n\n  pause(): void {\n    if (this.currentPauseStart === undefined && this.recorderIO.recording) {\n      this.currentPauseStart = Date.now();\n    }\n\n    if (this.nextInChain) {\n      this.nextInChain.pause();\n    }\n  }\n\n  /**\n   * Resume playback and record the pause interval\n   */\n  resume(): void {\n    if (this.currentPauseStart !== undefined && this.recorderIO.recording) {\n      this.pauseWallTimes.push([this.currentPauseStart, Date.now()]);\n      this.currentPauseStart = undefined;\n    }\n\n    if (this.nextInChain) {\n      this.nextInChain.resume();\n    }\n  }\n\n  private resetPauseState(): void {\n    this.currentPauseStart = undefined;\n    this.pauseWallTimes = [];\n  }\n\n  onPlaybackFinished(options: PlaybackFinishedEvent): void {\n    const finishTime = Date.now();\n\n    super.onPlaybackFinished(options);\n\n    if (!this.recorderIO.recording) {\n      return;\n    }\n\n    if (this.currentPauseStart !== undefined) {\n      this.pauseWallTimes.push([this.currentPauseStart, finishTime]);\n      this.currentPauseStart = undefined;\n    }\n\n    if (this.accFrames.length === 0) {\n      this.resetPauseState();\n      return;\n    }\n\n    const playbackPosition = options.playbackPosition;\n\n    const pauseEvents: Array<[number, number]> = [];\n\n    if (this.pauseWallTimes.length > 0) {\n      const totalPauseDuration = this.pauseWallTimes.reduce(\n        (sum, [start, end]) => sum + (end - start),\n        0,\n      );\n      // Convert playbackPosition from seconds to milliseconds for wall time calculations\n      const playbackStartTime = finishTime - playbackPosition * 1000 - totalPauseDuration;\n\n      let accumulatedPause = 0;\n      for (const [pauseStart, pauseEnd] of this.pauseWallTimes) {\n        let position = (pauseStart - playbackStartTime - accumulatedPause) / 1000; // Convert to seconds\n        const duration = (pauseEnd - pauseStart) / 1000; // Convert to seconds\n        position = Math.max(0, Math.min(position, playbackPosition));\n        pauseEvents.push([position, duration]);\n        accumulatedPause += pauseEnd - pauseStart;\n      }\n    }\n\n    const buf: AudioFrame[] = [];\n    let accDur = 0;\n    const sampleRate = this.accFrames[0]!.sampleRate;\n    const numChannels = this.accFrames[0]!.channels;\n\n    let pauseIdx = 0;\n    let shouldBreak = false;\n\n    for (const frame of this.accFrames) {\n      let currentFrame = frame;\n      const frameDuration = frame.samplesPerChannel / frame.sampleRate;\n\n      if (frameDuration + accDur > playbackPosition) {\n        const [left] = splitFrame(currentFrame, playbackPosition - accDur);\n        currentFrame = left;\n        shouldBreak = true;\n      }\n\n      // Process any pauses before this frame starts\n      while (pauseIdx < pauseEvents.length && pauseEvents[pauseIdx]![0] <= accDur) {\n        const [, pauseDur] = pauseEvents[pauseIdx]!;\n        buf.push(createSilenceFrame(pauseDur, sampleRate, numChannels));\n        pauseIdx++;\n      }\n\n      // Process any pauses within this frame\n      const currentFrameDuration = currentFrame.samplesPerChannel / currentFrame.sampleRate;\n      while (\n        pauseIdx < pauseEvents.length &&\n        pauseEvents[pauseIdx]![0] < accDur + currentFrameDuration\n      ) {\n        const [pausePos, pauseDur] = pauseEvents[pauseIdx]!;\n        const [left, right] = splitFrame(currentFrame, pausePos - accDur);\n        buf.push(left);\n        accDur += left.samplesPerChannel / left.sampleRate;\n        buf.push(createSilenceFrame(pauseDur, sampleRate, numChannels));\n        currentFrame = right;\n        pauseIdx++;\n      }\n\n      buf.push(currentFrame);\n      accDur += currentFrame.samplesPerChannel / currentFrame.sampleRate;\n\n      if (shouldBreak) {\n        break;\n      }\n    }\n\n    // Process remaining pauses\n    while (pauseIdx < pauseEvents.length) {\n      const [pausePos, pauseDur] = pauseEvents[pauseIdx]!;\n      if (pausePos <= playbackPosition) {\n        buf.push(createSilenceFrame(pauseDur, sampleRate, numChannels));\n      }\n      pauseIdx++;\n    }\n\n    if (buf.length > 0) {\n      this.writeFn(buf);\n    }\n\n    this.accFrames = [];\n    this.resetPauseState();\n  }\n\n  async captureFrame(frame: AudioFrame): Promise<void> {\n    await super.captureFrame(frame);\n\n    if (this.recorderIO.recording) {\n      if (this._startedWallTime === undefined) {\n        this._startedWallTime = Date.now();\n      }\n      this.accFrames.push(frame);\n    }\n\n    if (this.nextInChain) {\n      await this.nextInChain.captureFrame(frame);\n    }\n  }\n\n  flush(): void {\n    super.flush();\n\n    if (this.nextInChain) {\n      this.nextInChain.flush();\n    }\n  }\n\n  clearBuffer(): void {\n    if (this.nextInChain) {\n      this.nextInChain.clearBuffer();\n    }\n  }\n}\n\n/**\n * Create a silent audio frame with the given duration\n */\nfunction createSilenceFrame(duration: number, sampleRate: number, numChannels: number): AudioFrame {\n  const samples = Math.floor(duration * sampleRate);\n  const data = new Int16Array(samples * numChannels); // Zero-filled by default\n  return new AudioFrame(data, sampleRate, numChannels, samples);\n}\n\n/**\n * Split an audio frame at the given position (in seconds)\n * Returns [left, right] frames\n */\nfunction splitFrame(frame: AudioFrame, position: number): [AudioFrame, AudioFrame] {\n  if (position <= 0) {\n    const emptyFrame = new AudioFrame(new Int16Array(0), frame.sampleRate, frame.channels, 0);\n    return [emptyFrame, frame];\n  }\n\n  const frameDuration = frame.samplesPerChannel / frame.sampleRate;\n  if (position >= frameDuration) {\n    const emptyFrame = new AudioFrame(new Int16Array(0), frame.sampleRate, frame.channels, 0);\n    return [frame, emptyFrame];\n  }\n\n  // samplesNeeded is samples per channel (i.e., sample count in time)\n  const samplesNeeded = Math.floor(position * frame.sampleRate);\n  // Int16Array: each element is one sample, interleaved by channel\n  // So total elements = samplesPerChannel * channels\n  const numChannels = frame.channels;\n\n  const leftData = frame.data.slice(0, samplesNeeded * numChannels);\n  const rightData = frame.data.slice(samplesNeeded * numChannels);\n\n  const leftFrame = new AudioFrame(leftData, frame.sampleRate, frame.channels, samplesNeeded);\n\n  const rightFrame = new AudioFrame(\n    rightData,\n    frame.sampleRate,\n    frame.channels,\n    frame.samplesPerChannel - samplesNeeded,\n  );\n\n  return [leftFrame, rightFrame];\n}\n"],"mappings":"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","names":[]}