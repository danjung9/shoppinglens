{"version":3,"sources":["../../../src/voice/testing/run_result.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AgentHandoffItem, ChatItem } from '../../llm/chat_context.js';\nimport type { Task } from '../../utils.js';\nimport { Future } from '../../utils.js';\nimport type { Agent } from '../agent.js';\nimport { type SpeechHandle, isSpeechHandle } from '../speech_handle.js';\nimport {\n  type AgentHandoffAssertOptions,\n  type AgentHandoffEvent,\n  type ChatMessageEvent,\n  type EventType,\n  type FunctionCallAssertOptions,\n  type FunctionCallEvent,\n  type FunctionCallOutputAssertOptions,\n  type FunctionCallOutputEvent,\n  type MessageAssertOptions,\n  type RunEvent,\n  isAgentHandoffEvent,\n  isChatMessageEvent,\n  isFunctionCallEvent,\n  isFunctionCallOutputEvent,\n} from './types.js';\n\n// Environment variable for verbose output\nconst evalsVerbose = parseInt(process.env.LIVEKIT_EVALS_VERBOSE || '0', 10);\n\n/**\n * Result of a test run containing recorded events and assertion utilities.\n *\n * @example\n * ```typescript\n * const result = await session.run({ userInput: 'Hello' });\n * result.expect.nextEvent().isMessage({ role: 'assistant' });\n * result.expect.noMoreEvents();\n * ```\n */\nexport class RunResult<T = unknown> {\n  private _events: RunEvent[] = [];\n  private doneFut = new Future<void>();\n  private userInput?: string;\n\n  private handles: Set<SpeechHandle | Task<void>> = new Set();\n  private lastSpeechHandle?: SpeechHandle;\n  private runAssert?: RunAssert;\n\n  // TODO(brian): Add typed output support for parity with Python\n  // - Add outputType?: new (...args: unknown[]) => T\n  // - Add finalOutput?: T\n  // - Implement markDone() to extract final_output from SpeechHandle.maybeRunFinalOutput\n  // - See Python: run_result.py lines 182-201\n\n  constructor(options?: { userInput?: string }) {\n    this.userInput = options?.userInput;\n  }\n\n  /**\n   * List of all recorded events generated during the run.\n   */\n  get events(): RunEvent[] {\n    return this._events;\n  }\n\n  /**\n   * Provides an assertion helper for verifying the run events.\n   */\n  get expect(): RunAssert {\n    if (evalsVerbose) {\n      const eventsStr = formatEvents(this._events)\n        .map((line) => `      ${line}`)\n        .join('\\n');\n      console.log(\n        `\\n+ RunResult {\\n    userInput: \"${this.userInput}\"\\n    events: [\\n${eventsStr}\\n    ]\\n  }`,\n      );\n    }\n\n    // Cache the RunAssert so cursor position persists across multiple .expect accesses\n    if (!this.runAssert) {\n      this.runAssert = new RunAssert(this);\n    }\n    return this.runAssert;\n  }\n\n  /**\n   * Returns the final output of the run after completion.\n   *\n   * @throws Error - Not implemented yet.\n   */\n  get finalOutput(): T {\n    // TODO(brian): Implement typed output support after AgentTask is implemented.\n    throw new Error('finalOutput is not yet implemented in JS.');\n  }\n\n  /**\n   * Indicates whether the run has finished processing all events.\n   */\n  done(): boolean {\n    return this.doneFut.done;\n  }\n\n  /**\n   * Wait for the RunResult to complete. Returns `this` for method chaining.\n   *\n   * @example\n   * ```ts\n   * const result = session.run({ userInput: 'Hi!' });\n   * await result.wait();  // waits for completion\n   * result.expect.nextEvent().isMessage({ role: 'assistant' });\n   * ```\n   */\n  async wait(): Promise<this> {\n    await this.doneFut.await;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Records an agent handoff event.\n   */\n  _agentHandoff(params: { item: AgentHandoffItem; oldAgent?: Agent; newAgent: Agent }): void {\n    const event: AgentHandoffEvent = {\n      type: 'agent_handoff',\n      item: params.item,\n      oldAgent: params.oldAgent,\n      newAgent: params.newAgent,\n    };\n    const index = this._findInsertionIndex(event.item.createdAt);\n    this._events.splice(index, 0, event);\n  }\n\n  /**\n   * @internal\n   * Called when a chat item is added during the run.\n   */\n  _itemAdded(item: ChatItem): void {\n    if (this.doneFut.done) {\n      return;\n    }\n\n    let event: RunEvent | undefined;\n\n    if (item.type === 'message') {\n      event = { type: 'message', item } as ChatMessageEvent;\n    } else if (item.type === 'function_call') {\n      event = { type: 'function_call', item } as FunctionCallEvent;\n    } else if (item.type === 'function_call_output') {\n      event = { type: 'function_call_output', item } as FunctionCallOutputEvent;\n    }\n\n    if (event) {\n      const index = this._findInsertionIndex(item.createdAt);\n      this._events.splice(index, 0, event);\n    }\n  }\n\n  /**\n   * @internal\n   * Watch a speech handle or task for completion.\n   */\n  _watchHandle(handle: SpeechHandle | Task<void>): void {\n    this.handles.add(handle);\n\n    if (isSpeechHandle(handle)) {\n      handle._addItemAddedCallback(this._itemAdded.bind(this));\n    }\n\n    handle.addDoneCallback(() => {\n      this._markDoneIfNeeded(handle);\n    });\n  }\n\n  /**\n   * @internal\n   * Unwatch a handle.\n   */\n  _unwatchHandle(handle: SpeechHandle | Task<void>): void {\n    this.handles.delete(handle);\n\n    if (isSpeechHandle(handle)) {\n      handle._removeItemAddedCallback(this._itemAdded.bind(this));\n    }\n  }\n\n  private _markDoneIfNeeded(handle: SpeechHandle | Task<void>): void {\n    if (isSpeechHandle(handle)) {\n      this.lastSpeechHandle = handle;\n    }\n\n    if ([...this.handles].every((h) => (isSpeechHandle(h) ? h.done() : h.done))) {\n      this._markDone();\n    }\n  }\n\n  private _markDone(): void {\n    // TODO(brian): Implement final output support after AgentTask is implemented.\n    // See Python run_result.py _mark_done() for reference:\n    // - Check lastSpeechHandle._maybeRunFinalOutput\n    // - Validate output type matches expected type\n    // - Set exception or resolve based on output\n    if (!this.doneFut.done) {\n      this.doneFut.resolve();\n    }\n  }\n\n  /**\n   * Find the correct insertion index to maintain chronological order.\n   */\n  private _findInsertionIndex(createdAt: number): number {\n    for (let i = this._events.length - 1; i >= 0; i--) {\n      if (this._events[i]!.item.createdAt <= createdAt) {\n        return i + 1;\n      }\n    }\n    return 0;\n  }\n}\n\n/**\n * Assertion helper for verifying run events in sequence.\n */\nexport class RunAssert {\n  private _events: RunEvent[];\n  private _currentIndex = 0;\n\n  // TODO(brian): Add range access for parity with Python __getitem__ slice support.\n  // - Add range(start?, end?) method returning EventRangeAssert\n  // - EventRangeAssert should have containsFunctionCall(), containsMessage() methods\n  // See Python run_result.py lines 247-251 for reference.\n\n  constructor(runResult: RunResult) {\n    this._events = runResult.events;\n  }\n\n  /**\n   * Access a specific event by index for assertions.\n   * Supports negative indices (e.g., -1 for last event).\n   *\n   * @example\n   * ```typescript\n   * result.expect.at(0).isMessage({ role: 'user' });\n   * result.expect.at(-1).isMessage({ role: 'assistant' });\n   * ```\n   */\n  at(index: number): EventAssert {\n    let normalizedIndex = index;\n    if (index < 0) {\n      normalizedIndex = this._events.length + index;\n    }\n\n    if (normalizedIndex < 0 || normalizedIndex >= this._events.length) {\n      this._raiseWithDebugInfo(\n        `at(${index}) out of range (total events: ${this._events.length})`,\n        normalizedIndex,\n      );\n    }\n\n    return new EventAssert(this._events[normalizedIndex]!, this, normalizedIndex);\n  }\n\n  /**\n   * Advance to the next event, optionally filtering by type.\n   *\n   * @example\n   * ```typescript\n   * result.expect.nextEvent().isMessage({ role: 'assistant' });\n   * result.expect.nextEvent({ type: 'function_call' }).isFunctionCall({ name: 'foo' });\n   * ```\n   */\n  nextEvent(options?: { type?: EventType }): EventAssert {\n    while (true) {\n      const evAssert = this._currentEvent();\n      this._currentIndex++;\n\n      if (!options?.type || evAssert.event().type === options.type) {\n        return evAssert;\n      }\n    }\n  }\n\n  /**\n   * Skip a specified number of upcoming events without assertions.\n   *\n   * @example\n   * ```typescript\n   * result.expect.skipNext(2);\n   * ```\n   */\n  skipNext(count: number = 1): this {\n    for (let i = 0; i < count; i++) {\n      if (this._currentIndex >= this._events.length) {\n        this._raiseWithDebugInfo(`Tried to skip ${count} event(s), but only ${i} were available.`);\n      }\n      this._currentIndex++;\n    }\n    return this;\n  }\n\n  /**\n   * Assert that there are no further events.\n   *\n   * @example\n   * ```typescript\n   * result.expect.noMoreEvents();\n   * ```\n   */\n  noMoreEvents(): void {\n    if (this._currentIndex < this._events.length) {\n      const event = this._events[this._currentIndex]!;\n      this._raiseWithDebugInfo(`Expected no more events, but found: ${event.type}`);\n    }\n  }\n\n  private _currentEvent(): EventAssert {\n    if (this._currentIndex >= this._events.length) {\n      this._raiseWithDebugInfo('Expected another event, but none left.');\n    }\n    return this.at(this._currentIndex);\n  }\n\n  /** @internal */\n  _raiseWithDebugInfo(message: string, index?: number): never {\n    const markerIndex = index ?? this._currentIndex;\n    const eventsStr = formatEvents(this._events, markerIndex).join('\\n');\n    throw new AssertionError(`${message}\\nContext around failure:\\n${eventsStr}`);\n  }\n}\n\n/**\n * Assertion wrapper for a single event.\n */\nexport class EventAssert {\n  protected _event: RunEvent;\n  protected _parent: RunAssert;\n  protected _index: number;\n\n  constructor(event: RunEvent, parent: RunAssert, index: number) {\n    this._event = event;\n    this._parent = parent;\n    this._index = index;\n  }\n\n  /**\n   * Get the underlying event.\n   */\n  event(): RunEvent {\n    return this._event;\n  }\n\n  protected _raise(message: string): never {\n    this._parent._raiseWithDebugInfo(message, this._index);\n  }\n\n  /**\n   * Verify this event is a message with optional role matching.\n   *\n   * @example\n   * ```typescript\n   * result.expect.nextEvent().isMessage({ role: 'assistant' });\n   * ```\n   */\n  isMessage(options?: MessageAssertOptions): MessageAssert {\n    if (!isChatMessageEvent(this._event)) {\n      this._raise(`Expected ChatMessageEvent, got ${this._event.type}`);\n    }\n\n    if (options?.role && this._event.item.role !== options.role) {\n      this._raise(`Expected role '${options.role}', got '${this._event.item.role}'`);\n    }\n\n    return new MessageAssert(this._event, this._parent, this._index);\n  }\n\n  /**\n   * Verify this event is a function call with optional name/args matching.\n   *\n   * @example\n   * ```typescript\n   * result.expect.nextEvent().isFunctionCall({ name: 'order_item', args: { id: 'big_mac' } });\n   * ```\n   */\n  isFunctionCall(options?: FunctionCallAssertOptions): FunctionCallAssert {\n    if (!isFunctionCallEvent(this._event)) {\n      this._raise(`Expected FunctionCallEvent, got ${this._event.type}`);\n    }\n\n    if (options?.name && this._event.item.name !== options.name) {\n      this._raise(`Expected call name '${options.name}', got '${this._event.item.name}'`);\n    }\n\n    if (options?.args) {\n      let actual: Record<string, unknown>;\n      try {\n        actual = JSON.parse(this._event.item.args);\n      } catch {\n        this._raise(`Failed to parse function call arguments: ${this._event.item.args}`);\n      }\n\n      for (const [key, value] of Object.entries(options.args)) {\n        if (!(key in actual) || actual[key] !== value) {\n          this._raise(\n            `For key '${key}', expected ${JSON.stringify(value)}, got ${JSON.stringify(actual[key])}`,\n          );\n        }\n      }\n    }\n\n    return new FunctionCallAssert(this._event, this._parent, this._index);\n  }\n\n  /**\n   * Verify this event is a function call output with optional matching.\n   *\n   * @example\n   * ```typescript\n   * result.expect.nextEvent().isFunctionCallOutput({ isError: false });\n   * ```\n   */\n  isFunctionCallOutput(options?: FunctionCallOutputAssertOptions): FunctionCallOutputAssert {\n    if (!isFunctionCallOutputEvent(this._event)) {\n      this._raise(`Expected FunctionCallOutputEvent, got ${this._event.type}`);\n    }\n\n    if (options?.output !== undefined && this._event.item.output !== options.output) {\n      this._raise(`Expected output '${options.output}', got '${this._event.item.output}'`);\n    }\n\n    if (options?.isError !== undefined && this._event.item.isError !== options.isError) {\n      this._raise(`Expected isError=${options.isError}, got ${this._event.item.isError}`);\n    }\n\n    return new FunctionCallOutputAssert(this._event, this._parent, this._index);\n  }\n\n  /**\n   * Verify this event is an agent handoff with optional type matching.\n   *\n   * @example\n   * ```typescript\n   * result.expect.nextEvent().isAgentHandoff({ newAgentType: MyAgent });\n   * ```\n   */\n  isAgentHandoff(options?: AgentHandoffAssertOptions): AgentHandoffAssert {\n    if (!isAgentHandoffEvent(this._event)) {\n      this._raise(`Expected AgentHandoffEvent, got ${this._event.type}`);\n    }\n\n    // Cast to the correct type after validation\n    const event = this._event as AgentHandoffEvent;\n\n    if (options?.newAgentType) {\n      const actualType = event.newAgent.constructor.name;\n      if (!(event.newAgent instanceof options.newAgentType)) {\n        this._raise(`Expected new_agent '${options.newAgentType.name}', got '${actualType}'`);\n      }\n    }\n\n    return new AgentHandoffAssert(event, this._parent, this._index);\n  }\n}\n\n/**\n * Assertion wrapper for message events.\n */\nexport class MessageAssert extends EventAssert {\n  protected declare _event: ChatMessageEvent;\n\n  constructor(event: ChatMessageEvent, parent: RunAssert, index: number) {\n    super(event, parent, index);\n  }\n\n  override event(): ChatMessageEvent {\n    return this._event;\n  }\n\n  // Phase 3: judge() method will be added here\n}\n\n/**\n * Assertion wrapper for function call events.\n */\nexport class FunctionCallAssert extends EventAssert {\n  protected declare _event: FunctionCallEvent;\n\n  constructor(event: FunctionCallEvent, parent: RunAssert, index: number) {\n    super(event, parent, index);\n  }\n\n  override event(): FunctionCallEvent {\n    return this._event;\n  }\n}\n\n/**\n * Assertion wrapper for function call output events.\n */\nexport class FunctionCallOutputAssert extends EventAssert {\n  protected declare _event: FunctionCallOutputEvent;\n\n  constructor(event: FunctionCallOutputEvent, parent: RunAssert, index: number) {\n    super(event, parent, index);\n  }\n\n  override event(): FunctionCallOutputEvent {\n    return this._event;\n  }\n}\n\n/**\n * Assertion wrapper for agent handoff events.\n */\nexport class AgentHandoffAssert extends EventAssert {\n  protected declare _event: AgentHandoffEvent;\n\n  constructor(event: AgentHandoffEvent, parent: RunAssert, index: number) {\n    super(event, parent, index);\n  }\n\n  override event(): AgentHandoffEvent {\n    return this._event;\n  }\n}\n\n/**\n * Custom assertion error for test failures.\n */\nexport class AssertionError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'AssertionError';\n    Error.captureStackTrace?.(this, AssertionError);\n  }\n}\n\n/**\n * Format events for debug output, optionally marking a selected index.\n */\nfunction formatEvents(events: RunEvent[], selectedIndex?: number): string[] {\n  const lines: string[] = [];\n\n  for (let i = 0; i < events.length; i++) {\n    const event = events[i]!;\n    let prefix = '';\n    if (selectedIndex !== undefined) {\n      prefix = i === selectedIndex ? '>>>' : '   ';\n    }\n\n    let line: string;\n    if (isChatMessageEvent(event)) {\n      const { role, content, interrupted } = event.item;\n      const textContent =\n        typeof content === 'string'\n          ? content\n          : Array.isArray(content)\n            ? content.filter((c): c is string => typeof c === 'string').join(' ')\n            : '';\n      const truncated = textContent.length > 50 ? textContent.slice(0, 50) + '...' : textContent;\n      line = `${prefix}[${i}] { type: \"message\", role: \"${role}\", content: \"${truncated}\", interrupted: ${interrupted} }`;\n    } else if (isFunctionCallEvent(event)) {\n      const { name, args } = event.item;\n      line = `${prefix}[${i}] { type: \"function_call\", name: \"${name}\", args: ${args} }`;\n    } else if (isFunctionCallOutputEvent(event)) {\n      const { output, isError } = event.item;\n      const truncated = output.length > 50 ? output.slice(0, 50) + '...' : output;\n      line = `${prefix}[${i}] { type: \"function_call_output\", output: \"${truncated}\", isError: ${isError} }`;\n    } else if (isAgentHandoffEvent(event)) {\n      line = `${prefix}[${i}] { type: \"agent_handoff\", oldAgent: \"${event.oldAgent?.constructor.name}\", newAgent: \"${event.newAgent.constructor.name}\" }`;\n    } else {\n      line = `${prefix}[${i}] ${event}`;\n    }\n\n    lines.push(line);\n  }\n\n  return lines;\n}\n"],"mappings":"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","names":[]}