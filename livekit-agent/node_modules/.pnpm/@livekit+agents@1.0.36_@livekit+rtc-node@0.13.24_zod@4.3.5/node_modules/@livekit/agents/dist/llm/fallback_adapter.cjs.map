{"version":3,"sources":["../../src/llm/fallback_adapter.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { APIConnectionError, APIError } from '../_exceptions.js';\nimport { log } from '../log.js';\nimport { type APIConnectOptions, DEFAULT_API_CONNECT_OPTIONS } from '../types.js';\nimport type { ChatContext } from './chat_context.js';\nimport type { ChatChunk } from './llm.js';\nimport { LLM, LLMStream } from './llm.js';\nimport type { ToolChoice, ToolContext } from './tool_context.js';\n\n/**\n * Default connection options for FallbackAdapter.\n * Uses max_retry=0 since fallback handles retries at a higher level.\n */\nconst DEFAULT_FALLBACK_API_CONNECT_OPTIONS: APIConnectOptions = {\n  maxRetry: 0,\n  timeoutMs: DEFAULT_API_CONNECT_OPTIONS.timeoutMs,\n  retryIntervalMs: DEFAULT_API_CONNECT_OPTIONS.retryIntervalMs,\n};\n\n/**\n * Internal status tracking for each LLM instance.\n */\ninterface LLMStatus {\n  available: boolean;\n  recoveringTask: Promise<void> | null;\n}\n\n/**\n * Event emitted when an LLM's availability changes.\n */\nexport interface AvailabilityChangedEvent {\n  llm: LLM;\n  available: boolean;\n}\n\n/**\n * Options for creating a FallbackAdapter.\n */\nexport interface FallbackAdapterOptions {\n  /** List of LLM instances to fallback to (in order). */\n  llms: LLM[];\n  /** Timeout for each LLM attempt in seconds. Defaults to 5.0. */\n  attemptTimeout?: number;\n  /** Internal retries per LLM before moving to next. Defaults to 0. */\n  maxRetryPerLLM?: number;\n  /** Interval between retries in seconds. Defaults to 0.5. */\n  retryInterval?: number;\n  /** Whether to retry when LLM fails after chunks are sent. Defaults to false. */\n  retryOnChunkSent?: boolean;\n}\n\n/**\n * FallbackAdapter is an LLM that can fallback to a different LLM if the current LLM fails.\n *\n * @example\n * ```typescript\n * const fallbackLLM = new FallbackAdapter({\n *   llms: [primaryLLM, secondaryLLM, tertiaryLLM],\n *   attemptTimeout: 5.0,\n *   maxRetryPerLLM: 1,\n * });\n * ```\n */\nexport class FallbackAdapter extends LLM {\n  readonly llms: LLM[];\n  readonly attemptTimeout: number;\n  readonly maxRetryPerLLM: number;\n  readonly retryInterval: number;\n  readonly retryOnChunkSent: boolean;\n\n  /** @internal */\n  _status: LLMStatus[];\n\n  private logger = log();\n\n  constructor(options: FallbackAdapterOptions) {\n    super();\n\n    if (!options.llms || options.llms.length < 1) {\n      throw new Error('at least one LLM instance must be provided.');\n    }\n\n    this.llms = options.llms;\n    this.attemptTimeout = options.attemptTimeout ?? 5.0;\n    this.maxRetryPerLLM = options.maxRetryPerLLM ?? 0;\n    this.retryInterval = options.retryInterval ?? 0.5;\n    this.retryOnChunkSent = options.retryOnChunkSent ?? false;\n\n    // Initialize status for each LLM\n    this._status = this.llms.map(() => ({\n      available: true,\n      recoveringTask: null,\n    }));\n\n    // Forward metrics_collected events from child LLMs\n    for (const llm of this.llms) {\n      llm.on('metrics_collected', (metrics) => {\n        this.emit('metrics_collected', metrics);\n      });\n    }\n  }\n\n  get model(): string {\n    return 'FallbackAdapter';\n  }\n\n  label(): string {\n    return 'FallbackAdapter';\n  }\n\n  chat(opts: {\n    chatCtx: ChatContext;\n    toolCtx?: ToolContext;\n    connOptions?: APIConnectOptions;\n    parallelToolCalls?: boolean;\n    toolChoice?: ToolChoice;\n    extraKwargs?: Record<string, unknown>;\n  }): LLMStream {\n    return new FallbackLLMStream(this, {\n      chatCtx: opts.chatCtx,\n      toolCtx: opts.toolCtx,\n      connOptions: opts.connOptions || DEFAULT_FALLBACK_API_CONNECT_OPTIONS,\n      parallelToolCalls: opts.parallelToolCalls,\n      toolChoice: opts.toolChoice,\n      extraKwargs: opts.extraKwargs,\n    });\n  }\n\n  /**\n   * Emit availability changed event.\n   * @internal\n   */\n  _emitAvailabilityChanged(llm: LLM, available: boolean): void {\n    const event: AvailabilityChangedEvent = { llm, available };\n    // Use type assertion for custom event\n    (this as unknown as { emit: (event: string, data: AvailabilityChangedEvent) => void }).emit(\n      'llm_availability_changed',\n      event,\n    );\n  }\n}\n\n/**\n * LLMStream implementation for FallbackAdapter.\n * Handles fallback logic between multiple LLM providers.\n */\nclass FallbackLLMStream extends LLMStream {\n  private adapter: FallbackAdapter;\n  private parallelToolCalls?: boolean;\n  private toolChoice?: ToolChoice;\n  private extraKwargs?: Record<string, unknown>;\n  private _currentStream?: LLMStream;\n  private _log = log();\n\n  constructor(\n    adapter: FallbackAdapter,\n    opts: {\n      chatCtx: ChatContext;\n      toolCtx?: ToolContext;\n      connOptions: APIConnectOptions;\n      parallelToolCalls?: boolean;\n      toolChoice?: ToolChoice;\n      extraKwargs?: Record<string, unknown>;\n    },\n  ) {\n    super(adapter, {\n      chatCtx: opts.chatCtx,\n      toolCtx: opts.toolCtx,\n      connOptions: opts.connOptions,\n    });\n    this.adapter = adapter;\n    this.parallelToolCalls = opts.parallelToolCalls;\n    this.toolChoice = opts.toolChoice;\n    this.extraKwargs = opts.extraKwargs;\n  }\n\n  /**\n   * Override chatCtx to return current stream's context if available.\n   */\n  override get chatCtx(): ChatContext {\n    return this._currentStream?.chatCtx ?? super.chatCtx;\n  }\n\n  /**\n   * Try to generate with a single LLM.\n   * Returns an async generator that yields chunks.\n   */\n  private async *tryGenerate(\n    llm: LLM,\n    checkRecovery: boolean = false,\n  ): AsyncGenerator<ChatChunk, void, unknown> {\n    const connOptions: APIConnectOptions = {\n      ...this.connOptions,\n      maxRetry: this.adapter.maxRetryPerLLM,\n      timeoutMs: this.adapter.attemptTimeout * 1000,\n      retryIntervalMs: this.adapter.retryInterval * 1000,\n    };\n\n    const stream = llm.chat({\n      chatCtx: super.chatCtx,\n      toolCtx: this.toolCtx,\n      connOptions,\n      parallelToolCalls: this.parallelToolCalls,\n      toolChoice: this.toolChoice,\n      extraKwargs: this.extraKwargs,\n    });\n\n    // Listen for error events - child LLMs emit errors via their LLM instance, not the stream\n    let streamError: Error | undefined;\n    const errorHandler = (ev: { error: Error }) => {\n      streamError = ev.error;\n    };\n    llm.on('error', errorHandler);\n\n    try {\n      let shouldSetCurrent = !checkRecovery;\n      for await (const chunk of stream) {\n        if (shouldSetCurrent) {\n          shouldSetCurrent = false;\n          this._currentStream = stream;\n        }\n        yield chunk;\n      }\n\n      // If an error was emitted but not thrown through iteration, throw it now\n      if (streamError) {\n        throw streamError;\n      }\n    } catch (error) {\n      if (error instanceof APIError) {\n        if (checkRecovery) {\n          this._log.warn({ llm: llm.label(), error }, 'recovery failed');\n        } else {\n          this._log.warn({ llm: llm.label(), error }, 'failed, switching to next LLM');\n        }\n        throw error;\n      }\n\n      // Handle timeout errors\n      if (error instanceof Error && error.name === 'AbortError') {\n        if (checkRecovery) {\n          this._log.warn({ llm: llm.label() }, 'recovery timed out');\n        } else {\n          this._log.warn({ llm: llm.label() }, 'timed out, switching to next LLM');\n        }\n        throw error;\n      }\n\n      // Unexpected error\n      if (checkRecovery) {\n        this._log.error({ llm: llm.label(), error }, 'recovery unexpected error');\n      } else {\n        this._log.error({ llm: llm.label(), error }, 'unexpected error, switching to next LLM');\n      }\n      throw error;\n    } finally {\n      llm.off('error', errorHandler);\n    }\n  }\n\n  /**\n   * Start background recovery task for an LLM.\n   */\n  private tryRecovery(llm: LLM, index: number): void {\n    const status = this.adapter._status[index]!;\n\n    // Skip if already recovering\n    if (status.recoveringTask !== null) {\n      return;\n    }\n\n    const recoverTask = async (): Promise<void> => {\n      try {\n        // Try to generate (just iterate to check if it works)\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for await (const _chunk of this.tryGenerate(llm, true)) {\n          // Just consume the stream to verify it works\n        }\n\n        // Recovery successful\n        status.available = true;\n        this._log.info({ llm: llm.label() }, 'LLM recovered');\n        this.adapter._emitAvailabilityChanged(llm, true);\n      } catch {\n        // Recovery failed, stay unavailable\n      } finally {\n        status.recoveringTask = null;\n      }\n    };\n\n    // Fire and forget\n    status.recoveringTask = recoverTask();\n  }\n\n  /**\n   * Main run method - iterates through LLMs with fallback logic.\n   */\n  protected async run(): Promise<void> {\n    const startTime = Date.now();\n\n    // Check if all LLMs are unavailable\n    const allFailed = this.adapter._status.every((s) => !s.available);\n    if (allFailed) {\n      this._log.error('all LLMs are unavailable, retrying...');\n    }\n\n    for (let i = 0; i < this.adapter.llms.length; i++) {\n      const llm = this.adapter.llms[i]!;\n      const status = this.adapter._status[i]!;\n\n      this._log.debug(\n        { llm: llm.label(), index: i, available: status.available, allFailed },\n        'checking LLM',\n      );\n\n      if (status.available || allFailed) {\n        let textSent = '';\n        const toolCallsSent: string[] = [];\n\n        try {\n          this._log.info({ llm: llm.label() }, 'FallbackAdapter: Attempting provider');\n\n          let chunkCount = 0;\n          for await (const chunk of this.tryGenerate(llm, false)) {\n            chunkCount++;\n            // Track what's been sent\n            if (chunk.delta) {\n              if (chunk.delta.content) {\n                textSent += chunk.delta.content;\n              }\n              if (chunk.delta.toolCalls) {\n                for (const tc of chunk.delta.toolCalls) {\n                  if (tc.name) {\n                    toolCallsSent.push(tc.name);\n                  }\n                }\n              }\n            }\n\n            // Forward chunk to queue\n            this._log.debug({ llm: llm.label(), chunkCount }, 'run: forwarding chunk to queue');\n            this.queue.put(chunk);\n          }\n\n          // Success!\n          this._log.info(\n            { llm: llm.label(), totalChunks: chunkCount, textLength: textSent.length },\n            'FallbackAdapter: Provider succeeded',\n          );\n          return;\n        } catch (error) {\n          // Mark as unavailable if it was available before\n          if (status.available) {\n            status.available = false;\n            this.adapter._emitAvailabilityChanged(llm, false);\n          }\n\n          // Check if we sent data before failing\n          if (textSent || toolCallsSent.length > 0) {\n            const extra = { textSent, toolCallsSent };\n\n            if (!this.adapter.retryOnChunkSent) {\n              this._log.error(\n                { llm: llm.label(), ...extra },\n                'failed after sending chunk, skip retrying. Set `retryOnChunkSent` to `true` to enable.',\n              );\n              throw error;\n            }\n\n            this._log.warn(\n              { llm: llm.label(), ...extra },\n              'failed after sending chunk, retrying...',\n            );\n          }\n        }\n      }\n\n      // Trigger background recovery for this LLM\n      this.tryRecovery(llm, i);\n    }\n\n    // All LLMs failed\n    const duration = (Date.now() - startTime) / 1000;\n    const labels = this.adapter.llms.map((l) => l.label()).join(', ');\n    throw new APIConnectionError({\n      message: `all LLMs failed (${labels}) after ${duration.toFixed(2)}s`,\n    });\n  }\n}\n"],"mappings":"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","names":[]}