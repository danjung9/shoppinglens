import { TypedEventEmitter } from '@livekit/typed-emitter';
import { g as TextStreamHandler, f as ByteStreamHandler } from './stream_reader-Ch2zvjU3.cjs';
import { E2EEManager, E2EEOptions } from './e2ee.cjs';
import { RemoteParticipant, LocalParticipant, Participant } from './participant.cjs';
import { EncryptionType } from './proto/e2ee_pb.cjs';
import { DisconnectReason } from './proto/participant_pb.cjs';
import { RoomInfo, ConnectionQuality, DataPacketKind, ConnectionState, IceTransportType, ContinualGatheringPolicy, IceServer, RoomOptions as RoomOptions$1 } from './proto/room_pb.cjs';
import { LocalTrack, RemoteTrack } from './track.cjs';
import { LocalTrackPublication, RemoteTrackPublication, TrackPublication } from './track_publication.cjs';
import { ChatMessage } from './types.cjs';
import '@livekit/mutex';
import 'node:fs';
import './data_streams/stream_writer.cjs';
import './ffi_client.cjs';
import '@bufbuild/protobuf';
import './napi/native.d.cjs';
import './proto/ffi_pb.cjs';
import './proto/track_pb.cjs';
import './proto/stats_pb.cjs';
import './proto/handle_pb.cjs';
import './proto/video_frame_pb.cjs';
import './proto/audio_frame_pb.cjs';
import './proto/rpc_pb.cjs';
import './proto/track_publication_pb.cjs';
import './proto/data_stream_pb.cjs';
import './rpc.cjs';
import './transcription.cjs';
import './audio_source.cjs';
import './audio_frame.cjs';
import './video_source.cjs';
import './video_frame.cjs';

interface RtcConfiguration {
    iceTransportType: IceTransportType;
    continualGatheringPolicy: ContinualGatheringPolicy;
    iceServers: IceServer[];
}
declare const defaultRtcConfiguration: RtcConfiguration;
interface RoomOptions {
    autoSubscribe: boolean;
    dynacast: boolean;
    /**
     * @deprecated Use `encryption` instead. See x for details
     */
    e2ee?: E2EEOptions;
    encryption?: E2EEOptions;
    rtcConfig?: RtcConfiguration;
}
declare const defaultRoomOptions: RoomOptions$1;
declare const Room_base: new () => TypedEventEmitter<RoomCallbacks>;
declare class Room extends Room_base {
    private info?;
    private ffiHandle?;
    /**
     * used to ensure events are processed sequentially and allow for
     * the local participant to acquire the lock while doing state updates related to FFI events
     * before processing the next events
     */
    private ffiEventLock;
    private byteStreamControllers;
    private textStreamControllers;
    private byteStreamHandlers;
    private textStreamHandlers;
    private preConnectEvents;
    private _token?;
    private _serverUrl?;
    e2eeManager?: E2EEManager;
    connectionState: ConnectionState;
    remoteParticipants: Map<string, RemoteParticipant>;
    localParticipant?: LocalParticipant;
    constructor();
    get name(): string | undefined;
    get metadata(): string | undefined;
    get isConnected(): boolean;
    /** @internal */
    get token(): string | undefined;
    /** @internal */
    get serverUrl(): string | undefined;
    /**
     * Gets the room's server ID. This ID is assigned by the LiveKit server
     * and is unique for each room session.
     * SID is assigned asynchronously after connection.
     * @returns Promise that resolves to the room's server ID, or empty string if not connected
     */
    getSid(): Promise<string>;
    get numParticipants(): number;
    get numPublishers(): number;
    get creationTime(): Date;
    get isRecording(): boolean;
    /**
     * The time in seconds after which a room will be closed after the last
     * participant has disconnected.
     */
    get departureTimeout(): number;
    /**
     * The time in seconds after which an empty room will be automatically closed.
     */
    get emptyTimeout(): number;
    /**
     * Connects to a LiveKit room using the provided URL and access token.
     * @param url - The WebSocket URL of the LiveKit server
     * @param token - A valid LiveKit access token for authentication
     * @param opts - Optional room configuration options
     * @throws ConnectError - if connection fails
     */
    connect(url: string, token: string, opts?: RoomOptions): Promise<void>;
    /**
     * Disconnects from the room and cleans up all resources.
     * This will stop all tracks and close the connection.
     */
    disconnect(): Promise<void>;
    /**
     * Registers a handler for incoming text data streams on a specific topic.
     * Text streams are used for receiving structured text data from other participants.
     * @param topic - The topic to listen for text streams on
     * @param callback - Function to handle incoming text stream data
     * @throws Error - if a handler for this topic is already registered
     */
    registerTextStreamHandler(topic: string, callback: TextStreamHandler): void;
    unregisterTextStreamHandler(topic: string): void;
    /**
     * Registers a handler for incoming byte data streams on a specific topic.
     * Byte streams are used for receiving binary data like files from other participants.
     * @param topic - The topic to listen for byte streams on
     * @param callback - Function to handle incoming byte stream data
     * @throws Error - if a handler for this topic is already registered
     */
    registerByteStreamHandler(topic: string, callback: ByteStreamHandler): void;
    unregisterByteStreamHandler(topic: string): void;
    private onFfiEvent;
    private processFfiEvent;
    private retrieveParticipantByIdentity;
    private requireParticipantByIdentity;
    private requireRemoteParticipant;
    private requirePublicationOfParticipant;
    private requirePublicationOfRemoteParticipant;
    private createRemoteParticipant;
    private handleStreamHeader;
    private handleStreamChunk;
    private handleStreamTrailer;
}
declare class ConnectError extends Error {
    constructor(message: string);
}
type RoomCallbacks = {
    participantConnected: (participant: RemoteParticipant) => void;
    participantDisconnected: (participant: RemoteParticipant) => void;
    localTrackPublished: (publication: LocalTrackPublication, participant: LocalParticipant) => void;
    localTrackUnpublished: (publication: LocalTrackPublication, participant: LocalParticipant) => void;
    localTrackSubscribed: (track: LocalTrack) => void;
    trackPublished: (publication: RemoteTrackPublication, participant: RemoteParticipant) => void;
    trackUnpublished: (publication: RemoteTrackPublication, participant: RemoteParticipant) => void;
    trackSubscribed: (track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) => void;
    trackUnsubscribed: (track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) => void;
    trackSubscriptionFailed: (trackSid: string, participant: RemoteParticipant, reason?: string) => void;
    trackMuted: (publication: TrackPublication, participant: Participant) => void;
    trackUnmuted: (publication: TrackPublication, participant: Participant) => void;
    activeSpeakersChanged: (speakers: Participant[]) => void;
    roomMetadataChanged: (metadata: string) => void;
    roomInfoUpdated: (info: RoomInfo) => void;
    participantMetadataChanged: (metadata: string | undefined, participant: Participant) => void;
    participantNameChanged: (name: string, participant: Participant) => void;
    participantAttributesChanged: (changedAttributes: Record<string, string>, participant: Participant) => void;
    participantEncryptionStatusChanged: (isEncrypted: boolean, participant: Participant) => void;
    connectionQualityChanged: (quality: ConnectionQuality, participant: Participant) => void;
    dataReceived: (payload: Uint8Array, participant?: RemoteParticipant, kind?: DataPacketKind, topic?: string, encryptionType?: EncryptionType) => void;
    chatMessage: (message: ChatMessage, participant?: Participant) => void;
    dtmfReceived: (code: number, digit: string, participant: RemoteParticipant) => void;
    encryptionError: (error: Error) => void;
    connectionStateChanged: (state: ConnectionState) => void;
    connected: () => void;
    disconnected: (reason: DisconnectReason) => void;
    reconnecting: () => void;
    reconnected: () => void;
    roomSidChanged: (sid: string) => void;
    roomUpdated: () => void;
    moved: () => void;
    tokenRefreshed: () => void;
};
declare enum RoomEvent {
    ParticipantConnected = "participantConnected",
    ParticipantDisconnected = "participantDisconnected",
    LocalTrackPublished = "localTrackPublished",
    LocalTrackUnpublished = "localTrackUnpublished",
    LocalTrackSubscribed = "localTrackSubscribed",
    TrackPublished = "trackPublished",
    TrackUnpublished = "trackUnpublished",
    TrackSubscribed = "trackSubscribed",
    TrackUnsubscribed = "trackUnsubscribed",
    TrackSubscriptionFailed = "trackSubscriptionFailed",
    TrackMuted = "trackMuted",
    TrackUnmuted = "trackUnmuted",
    ActiveSpeakersChanged = "activeSpeakersChanged",
    RoomMetadataChanged = "roomMetadataChanged",
    RoomSidChanged = "roomSidChanged",
    ParticipantMetadataChanged = "participantMetadataChanged",
    ParticipantNameChanged = "participantNameChanged",
    ParticipantAttributesChanged = "participantAttributesChanged",
    ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged",
    ConnectionQualityChanged = "connectionQualityChanged",
    DataReceived = "dataReceived",
    ChatMessage = "chatMessage",
    DtmfReceived = "dtmfReceived",
    EncryptionError = "encryptionError",
    ConnectionStateChanged = "connectionStateChanged",
    Connected = "connected",
    Disconnected = "disconnected",
    Reconnecting = "reconnecting",
    Reconnected = "reconnected",
    RoomUpdated = "roomUpdated",
    Moved = "moved",
    TokenRefreshed = "tokenRefreshed"
}

export { ConnectError, Room, type RoomCallbacks, RoomEvent, type RoomOptions, type RtcConfiguration, defaultRoomOptions, defaultRtcConfiguration };
