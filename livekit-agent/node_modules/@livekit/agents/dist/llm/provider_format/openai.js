import { serializeImage } from "../utils.js";
import { groupToolCalls } from "./utils.js";
async function toChatCtx(chatCtx, injectDummyUserMessage = true) {
  const itemGroups = groupToolCalls(chatCtx);
  const messages = [];
  for (const group of itemGroups) {
    if (group.isEmpty) continue;
    const message = group.message ? await toChatItem(group.message) : { role: "assistant" };
    const toolCalls = group.toolCalls.map((toolCall) => {
      const tc = {
        type: "function",
        id: toolCall.callId,
        function: { name: toolCall.name, arguments: toolCall.args }
      };
      const googleExtra = getGoogleExtra(toolCall);
      if (googleExtra) {
        tc.extra_content = { google: googleExtra };
      }
      return tc;
    });
    if (toolCalls.length > 0) {
      message["tool_calls"] = toolCalls;
    }
    messages.push(message);
    for (const toolOutput of group.toolOutputs) {
      messages.push(await toChatItem(toolOutput));
    }
  }
  return messages;
}
async function toChatItem(item) {
  if (item.type === "message") {
    const listContent = [];
    let textContent = "";
    for (const content of item.content) {
      if (typeof content === "string") {
        if (textContent) textContent += "\n";
        textContent += content;
      } else if (content.type === "image_content") {
        listContent.push(await toImageContent(content));
      } else {
        throw new Error(`Unsupported content type: ${content.type}`);
      }
    }
    const result = { role: item.role };
    if (listContent.length === 0) {
      result.content = textContent;
    } else {
      if (textContent.length > 0) {
        listContent.push({ type: "text", text: textContent });
      }
      result.content = listContent;
    }
    return result;
  } else if (item.type === "function_call") {
    const tc = {
      id: item.callId,
      type: "function",
      function: { name: item.name, arguments: item.args }
    };
    const googleExtra = getGoogleExtra(item);
    if (googleExtra) {
      tc.extra_content = { google: googleExtra };
    }
    return {
      role: "assistant",
      tool_calls: [tc]
    };
  } else if (item.type === "function_call_output") {
    return {
      role: "tool",
      tool_call_id: item.callId,
      content: item.output
    };
  }
  throw new Error(`Unsupported item type: ${item["type"]}`);
}
function getGoogleExtra(item) {
  var _a;
  const googleExtra = ((_a = item.extra) == null ? void 0 : _a.google) || (item.thoughtSignature ? { thoughtSignature: item.thoughtSignature } : void 0);
  return googleExtra;
}
async function toImageContent(content) {
  const cacheKey = "serialized_image";
  let serialized;
  if (content._cache[cacheKey] === void 0) {
    serialized = await serializeImage(content);
    content._cache[cacheKey] = serialized;
  }
  serialized = content._cache[cacheKey];
  if (serialized.externalUrl) {
    return {
      type: "image_url",
      image_url: {
        url: serialized.externalUrl,
        detail: serialized.inferenceDetail
      }
    };
  }
  if (serialized.base64Data === void 0) {
    throw new Error("Serialized image has no data bytes");
  }
  return {
    type: "image_url",
    image_url: {
      url: `data:${serialized.mimeType};base64,${serialized.base64Data}`,
      detail: serialized.inferenceDetail
    }
  };
}
export {
  toChatCtx
};
//# sourceMappingURL=openai.js.map