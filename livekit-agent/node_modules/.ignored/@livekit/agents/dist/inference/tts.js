import { WebSocket } from "ws";
import { APIError, APIStatusError } from "../_exceptions.js";
import { AudioByteStream } from "../audio.js";
import { ConnectionPool } from "../connection_pool.js";
import { log } from "../log.js";
import { createStreamChannel } from "../stream/stream_channel.js";
import { basic as tokenizeBasic } from "../tokenize/index.js";
import { SynthesizeStream as BaseSynthesizeStream, TTS as BaseTTS } from "../tts/index.js";
import { DEFAULT_API_CONNECT_OPTIONS } from "../types.js";
import { Event, Future, Task, cancelAndWait, combineSignals, shortuuid } from "../utils.js";
import {
  ttsClientEventSchema,
  ttsServerEventSchema
} from "./api_protos.js";
import { connectWs, createAccessToken } from "./utils.js";
const DEFAULT_ENCODING = "pcm_s16le";
const DEFAULT_SAMPLE_RATE = 16e3;
const DEFAULT_BASE_URL = "https://agent-gateway.livekit.cloud/v1";
const NUM_CHANNELS = 1;
const DEFAULT_LANGUAGE = "en";
class TTS extends BaseTTS {
  opts;
  streams = /* @__PURE__ */ new Set();
  pool;
  #logger = log();
  constructor(opts) {
    const sampleRate = (opts == null ? void 0 : opts.sampleRate) ?? DEFAULT_SAMPLE_RATE;
    super(sampleRate, 1, { streaming: true });
    const {
      model,
      voice,
      language = DEFAULT_LANGUAGE,
      baseURL,
      encoding = DEFAULT_ENCODING,
      apiKey,
      apiSecret,
      modelOptions = {}
    } = opts || {};
    const lkBaseURL = baseURL || process.env.LIVEKIT_INFERENCE_URL || DEFAULT_BASE_URL;
    const lkApiKey = apiKey || process.env.LIVEKIT_INFERENCE_API_KEY || process.env.LIVEKIT_API_KEY;
    if (!lkApiKey) {
      throw new Error("apiKey is required: pass apiKey or set LIVEKIT_API_KEY");
    }
    const lkApiSecret = apiSecret || process.env.LIVEKIT_INFERENCE_API_SECRET || process.env.LIVEKIT_API_SECRET;
    if (!lkApiSecret) {
      throw new Error("apiSecret is required: pass apiSecret or set LIVEKIT_API_SECRET");
    }
    let nextModel = model;
    let nextVoice = voice;
    if (typeof nextModel === "string") {
      const idx = nextModel.lastIndexOf(":");
      if (idx !== -1) {
        const voiceFromModel = nextModel.slice(idx + 1);
        if (nextVoice && nextVoice !== voiceFromModel) {
          this.#logger.warn(
            "`voice` is provided via both argument and model, using the one from the argument",
            { voice: nextVoice, model: nextModel }
          );
        } else {
          nextVoice = voiceFromModel;
        }
        nextModel = nextModel.slice(0, idx);
      }
    }
    this.opts = {
      model: nextModel,
      voice: nextVoice,
      language,
      encoding,
      sampleRate,
      baseURL: lkBaseURL,
      apiKey: lkApiKey,
      apiSecret: lkApiSecret,
      modelOptions
    };
    this.pool = new ConnectionPool({
      connectCb: (timeout) => this.connectWs(timeout),
      closeCb: (ws) => this.closeWs(ws),
      maxSessionDuration: 3e5,
      markRefreshedOnGet: true,
      connectTimeout: 1e4
      // 10 seconds default
    });
  }
  get label() {
    return "inference.TTS";
  }
  static fromModelString(modelString) {
    if (modelString.includes(":")) {
      const [model, voice] = modelString.split(":");
      return new TTS({ model, voice });
    }
    return new TTS({ model: modelString });
  }
  updateOptions(opts) {
    this.opts = { ...this.opts, ...opts };
    for (const stream of this.streams) {
      stream.updateOptions(opts);
    }
  }
  synthesize(_) {
    throw new Error("ChunkedStream is not implemented");
  }
  stream(options) {
    const { connOptions = DEFAULT_API_CONNECT_OPTIONS } = options || {};
    const stream = new SynthesizeStream(this, { ...this.opts }, connOptions);
    this.streams.add(stream);
    return stream;
  }
  async connectWs(timeout) {
    let baseURL = this.opts.baseURL;
    if (baseURL.startsWith("http://") || baseURL.startsWith("https://")) {
      baseURL = baseURL.replace("http", "ws");
    }
    const token = await createAccessToken(this.opts.apiKey, this.opts.apiSecret);
    const url = `${baseURL}/tts`;
    const headers = { Authorization: `Bearer ${token}` };
    const params = {
      type: "session.create",
      sample_rate: String(this.opts.sampleRate),
      encoding: this.opts.encoding,
      extra: this.opts.modelOptions
    };
    if (this.opts.voice) params.voice = this.opts.voice;
    if (this.opts.model) params.model = this.opts.model;
    if (this.opts.language) params.language = this.opts.language;
    this.#logger.debug({ url }, "inference.TTS creating new websocket connection (pool miss)");
    const socket = await connectWs(url, headers, timeout);
    socket.send(JSON.stringify(params));
    return socket;
  }
  async closeWs(ws) {
    await ws.close();
  }
  prewarm() {
    this.pool.prewarm();
  }
  async close() {
    for (const stream of this.streams) {
      await stream.close();
    }
    this.streams.clear();
    await this.pool.close();
  }
}
class SynthesizeStream extends BaseSynthesizeStream {
  opts;
  tts;
  #logger = log();
  constructor(tts, opts, connOptions) {
    super(tts, connOptions);
    this.opts = opts;
    this.tts = tts;
  }
  get label() {
    return "inference.SynthesizeStream";
  }
  updateOptions(opts) {
    this.opts = { ...this.opts, ...opts };
  }
  async run() {
    let closing = false;
    let lastFrame;
    const sendTokenizerStream = new tokenizeBasic.SentenceTokenizer().stream();
    const eventChannel = createStreamChannel();
    const requestId = shortuuid("tts_request_");
    const inputSentEvent = new Event();
    const completionFuture = new Future();
    const resourceCleanup = async () => {
      if (closing) return;
      closing = true;
      sendTokenizerStream.close();
      await eventChannel.close();
    };
    const sendClientEvent = async (event, ws, signal) => {
      if (signal.aborted || closing) return;
      const validatedEvent = await ttsClientEventSchema.parseAsync(event);
      if (ws.readyState !== WebSocket.OPEN) {
        this.#logger.warn("Trying to send client TTS event to a closed WebSocket");
        return;
      }
      ws.send(JSON.stringify(validatedEvent));
    };
    const sendLastFrame = (segmentId, final) => {
      if (lastFrame) {
        this.queue.put({ requestId, segmentId, frame: lastFrame, final });
        lastFrame = void 0;
      }
    };
    const createInputTask = async (signal) => {
      for await (const data of this.input) {
        if (signal.aborted || closing) break;
        if (data === SynthesizeStream.FLUSH_SENTINEL) {
          sendTokenizerStream.flush();
          continue;
        }
        sendTokenizerStream.pushText(data);
      }
      if (!closing) {
        sendTokenizerStream.endInput();
      }
    };
    const createSentenceStreamTask = async (ws, signal) => {
      for await (const ev of sendTokenizerStream) {
        if (signal.aborted || closing) break;
        await sendClientEvent(
          {
            type: "input_transcript",
            transcript: ev.token + " "
          },
          ws,
          signal
        );
        inputSentEvent.set();
      }
      await sendClientEvent({ type: "session.flush" }, ws, signal);
      inputSentEvent.set();
    };
    const createWsListenerTask = async (ws, signal) => {
      const onMessage = (data) => {
        try {
          const eventJson = JSON.parse(data.toString());
          const validatedEvent = ttsServerEventSchema.parse(eventJson);
          void eventChannel.write(validatedEvent).catch((error) => {
            this.#logger.debug(
              { error },
              "Failed writing TTS event to stream channel (likely closed)"
            );
          });
        } catch (e) {
          this.#logger.error({ error: e }, "Error parsing WebSocket message");
        }
      };
      const onError = (e) => {
        var _a;
        this.#logger.error({ error: e }, "WebSocket error");
        void resourceCleanup();
        try {
          (_a = ws.terminate) == null ? void 0 : _a.call(ws);
        } catch {
        }
        this.tts.pool.remove(ws);
        completionFuture.reject(e);
      };
      const onClose = () => {
        if (!closing) {
          this.#logger.error("WebSocket closed unexpectedly");
          void resourceCleanup();
          this.tts.pool.remove(ws);
          completionFuture.reject(
            new APIStatusError({
              message: "Gateway connection closed unexpectedly",
              options: { requestId }
            })
          );
        }
      };
      const onAbort = () => {
        var _a;
        void resourceCleanup();
        try {
          (_a = ws.terminate) == null ? void 0 : _a.call(ws);
        } catch {
        }
        this.tts.pool.remove(ws);
        inputSentEvent.set();
        completionFuture.resolve();
      };
      ws.on("message", onMessage);
      ws.on("error", onError);
      ws.on("close", onClose);
      signal.addEventListener("abort", onAbort);
      try {
        await completionFuture.await;
      } finally {
        ws.off("message", onMessage);
        ws.off("error", onError);
        ws.off("close", onClose);
        signal.removeEventListener("abort", onAbort);
      }
    };
    const createRecvTask = async (signal) => {
      let currentSessionId = null;
      const bstream = new AudioByteStream(this.opts.sampleRate, NUM_CHANNELS);
      const serverEventStream = eventChannel.stream();
      const reader = serverEventStream.getReader();
      try {
        await inputSentEvent.wait();
        while (!this.closed && !signal.aborted) {
          const result = await reader.read();
          if (signal.aborted) return;
          if (result.done) return;
          const serverEvent = result.value;
          switch (serverEvent.type) {
            case "session.created":
              currentSessionId = serverEvent.session_id;
              break;
            case "output_audio":
              const base64Data = new Int8Array(Buffer.from(serverEvent.audio, "base64"));
              for (const frame of bstream.write(base64Data.buffer)) {
                sendLastFrame(currentSessionId, false);
                lastFrame = frame;
              }
              break;
            case "done":
              for (const frame of bstream.flush()) {
                sendLastFrame(currentSessionId, false);
                lastFrame = frame;
              }
              sendLastFrame(currentSessionId, true);
              this.queue.put(SynthesizeStream.END_OF_STREAM);
              await resourceCleanup();
              completionFuture.resolve();
              return;
            case "session.closed":
              await resourceCleanup();
              completionFuture.resolve();
              return;
            case "error":
              this.#logger.error(
                { serverEvent },
                "Received error message from LiveKit TTS WebSocket"
              );
              await resourceCleanup();
              completionFuture.reject(
                new APIError(`LiveKit TTS returned error: ${serverEvent.message}`)
              );
              return;
            default:
              this.#logger.warn("Unexpected message %s", serverEvent);
              break;
          }
        }
      } finally {
        reader.releaseLock();
        try {
          await serverEventStream.cancel();
        } catch (e) {
          this.#logger.debug("Error cancelling serverEventStream (may already be cancelled):", e);
        }
      }
    };
    try {
      await this.tts.pool.withConnection(
        async (ws) => {
          try {
            const runController = new AbortController();
            const onStreamAbort = () => runController.abort(this.abortController.signal.reason);
            this.abortController.signal.addEventListener("abort", onStreamAbort, { once: true });
            const tasks = [
              Task.from(
                async (controller) => {
                  const combined = combineSignals(runController.signal, controller.signal);
                  await createInputTask(combined);
                },
                void 0,
                "inference-tts-input"
              ),
              Task.from(
                async (controller) => {
                  const combined = combineSignals(runController.signal, controller.signal);
                  await createSentenceStreamTask(ws, combined);
                },
                void 0,
                "inference-tts-sentence"
              ),
              Task.from(
                async (controller) => {
                  const combined = combineSignals(runController.signal, controller.signal);
                  await createWsListenerTask(ws, combined);
                },
                void 0,
                "inference-tts-ws-listener"
              ),
              Task.from(
                async (controller) => {
                  const combined = combineSignals(runController.signal, controller.signal);
                  await createRecvTask(combined);
                },
                void 0,
                "inference-tts-recv"
              )
            ];
            try {
              await Promise.all(tasks.map((t) => t.result));
            } finally {
              inputSentEvent.set();
              await resourceCleanup();
              await cancelAndWait(tasks, 5e3);
              this.abortController.signal.removeEventListener("abort", onStreamAbort);
            }
          } catch (e) {
            if (e instanceof Error && e.name === "AbortError") {
              return;
            }
            throw e;
          }
        },
        {
          timeout: this.connOptions.timeoutMs
        }
      );
    } catch (e) {
      if (e instanceof Error && e.name === "AbortError") {
        return;
      }
      throw e;
    } finally {
      await resourceCleanup();
    }
  }
}
export {
  SynthesizeStream,
  TTS
};
//# sourceMappingURL=tts.js.map