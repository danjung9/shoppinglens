import { Mutex } from "@livekit/mutex";
import { waitForAbort } from "./utils.js";
class ConnectionPool {
  maxSessionDuration;
  markRefreshedOnGet;
  connectCb;
  closeCb;
  connectTimeout;
  // Track connections and their creation timestamps
  connections = /* @__PURE__ */ new Map();
  // Available connections ready for reuse
  available = /* @__PURE__ */ new Set();
  // Connections queued for closing
  toClose = /* @__PURE__ */ new Set();
  // Mutex for connection operations
  connectLock = new Mutex();
  // Prewarm task reference
  prewarmController;
  constructor(options) {
    this.maxSessionDuration = options.maxSessionDuration;
    this.markRefreshedOnGet = options.markRefreshedOnGet ?? false;
    this.connectCb = options.connectCb;
    this.closeCb = options.closeCb;
    this.connectTimeout = options.connectTimeout ?? 1e4;
  }
  /**
   * Create a new connection.
   *
   * @param timeout - Connection timeout in milliseconds
   * @returns The new connection object
   * @throws If connectCb is not provided or connection fails
   */
  async _connect(timeout) {
    const connection = await this.connectCb(timeout);
    this.connections.set(connection, Date.now());
    return connection;
  }
  /**
   * Drain and close all connections queued for closing.
   */
  async _drainToClose() {
    const connectionsToClose = Array.from(this.toClose);
    this.toClose.clear();
    for (const conn of connectionsToClose) {
      await this._maybeCloseConnection(conn);
    }
  }
  /**
   * Close a connection if closeCb is provided.
   *
   * @param conn - The connection to close
   */
  async _maybeCloseConnection(conn) {
    if (this.closeCb) {
      await this.closeCb(conn);
    }
  }
  _abortError() {
    const error = new Error("The operation was aborted.");
    error.name = "AbortError";
    return error;
  }
  /**
   * Get an available connection or create a new one if needed.
   *
   * @param timeout - Connection timeout in milliseconds
   * @returns An active connection object
   */
  async get(timeout) {
    const unlock = await this.connectLock.lock();
    try {
      await this._drainToClose();
      const now = Date.now();
      while (this.available.size > 0) {
        const conn = this.available.values().next().value;
        this.available.delete(conn);
        if (this.maxSessionDuration === void 0 || now - (this.connections.get(conn) ?? 0) <= this.maxSessionDuration) {
          if (this.markRefreshedOnGet) {
            this.connections.set(conn, now);
          }
          return conn;
        }
        if (this.connections.has(conn)) {
          this.connections.delete(conn);
        }
        this.toClose.delete(conn);
        await this._maybeCloseConnection(conn);
      }
      return await this._connect(timeout ?? this.connectTimeout);
    } finally {
      unlock();
    }
  }
  /**
   * Mark a connection as available for reuse.
   *
   * If connection has been removed, it will not be added to the pool.
   *
   * @param conn - The connection to make available
   */
  put(conn) {
    if (this.connections.has(conn)) {
      this.available.add(conn);
      return;
    }
  }
  /**
   * Remove a specific connection from the pool.
   *
   * Marks the connection to be closed during the next drain cycle.
   *
   * @param conn - The connection to remove
   */
  remove(conn) {
    this.available.delete(conn);
    if (this.connections.has(conn)) {
      this.toClose.add(conn);
      this.connections.delete(conn);
      void (async () => {
        const unlock = await this.connectLock.lock();
        try {
          if (!this.toClose.has(conn)) return;
          await this._maybeCloseConnection(conn);
          this.toClose.delete(conn);
        } finally {
          unlock();
        }
      })();
    }
  }
  /**
   * Clear all existing connections.
   *
   * Marks all current connections to be closed during the next drain cycle.
   */
  invalidate() {
    for (const conn of this.connections.keys()) {
      this.toClose.add(conn);
    }
    this.connections.clear();
    this.available.clear();
  }
  /**
   * Initiate prewarming of the connection pool without blocking.
   *
   * This method starts a background task that creates a new connection if none exist.
   * The task automatically cleans itself up when the connection pool is closed.
   */
  prewarm() {
    if (this.prewarmController || this.connections.size > 0) {
      return;
    }
    const controller = new AbortController();
    this.prewarmController = controller;
    this._prewarmImpl(controller.signal).catch(() => {
    });
  }
  async _prewarmImpl(signal) {
    const unlock = await this.connectLock.lock();
    try {
      if (signal.aborted) {
        return;
      }
      if (this.connections.size === 0) {
        const conn = await this._connect(this.connectTimeout);
        this.available.add(conn);
      }
    } finally {
      unlock();
    }
  }
  /**
   * Get a connection from the pool and automatically return it when done.
   * Handles abort signals and ensures proper cleanup.
   *
   * @param fn - Function to execute with the connection
   * @param options - Options including timeout and abort signal
   * @returns The result of the function
   */
  async withConnection(fn, options) {
    var _a;
    if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {
      throw this._abortError();
    }
    const conn = await this.get(options == null ? void 0 : options.timeout);
    const signal = options == null ? void 0 : options.signal;
    try {
      const fnPromise = fn(conn);
      const result = signal ? await Promise.race([
        fnPromise.then((value) => ({ type: "result", value })),
        waitForAbort(signal).then(() => ({ type: "abort" }))
      ]).then((r) => {
        if (r.type === "abort") throw this._abortError();
        return r.value;
      }) : await fnPromise;
      this.put(conn);
      return result;
    } catch (error) {
      this.remove(conn);
      throw error;
    }
  }
  /**
   * Close all connections, draining any pending connection closures.
   */
  async close() {
    if (this.prewarmController) {
      this.prewarmController.abort();
      this.prewarmController = void 0;
    }
    this.invalidate();
    await this._drainToClose();
  }
}
export {
  ConnectionPool
};
//# sourceMappingURL=connection_pool.js.map