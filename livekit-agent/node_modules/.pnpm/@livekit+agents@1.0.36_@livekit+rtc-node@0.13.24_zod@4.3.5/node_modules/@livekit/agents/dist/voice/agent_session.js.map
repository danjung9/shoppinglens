{"version":3,"sources":["../../src/voice/agent_session.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame, Room } from '@livekit/rtc-node';\nimport type { TypedEventEmitter as TypedEmitter } from '@livekit/typed-emitter';\nimport type { Context, Span } from '@opentelemetry/api';\nimport { ROOT_CONTEXT, context as otelContext, trace } from '@opentelemetry/api';\nimport { EventEmitter } from 'node:events';\nimport type { ReadableStream } from 'node:stream/web';\nimport {\n  LLM as InferenceLLM,\n  STT as InferenceSTT,\n  TTS as InferenceTTS,\n  type LLMModels,\n  type STTModelString,\n  type TTSModelString,\n} from '../inference/index.js';\nimport { type JobContext, getJobContext } from '../job.js';\nimport type { FunctionCall, FunctionCallOutput } from '../llm/chat_context.js';\nimport { AgentHandoffItem, ChatContext, ChatMessage } from '../llm/chat_context.js';\nimport type { LLM, RealtimeModel, RealtimeModelError, ToolChoice } from '../llm/index.js';\nimport type { LLMError } from '../llm/llm.js';\nimport { log } from '../log.js';\nimport type { STT } from '../stt/index.js';\nimport type { STTError } from '../stt/stt.js';\nimport { traceTypes, tracer } from '../telemetry/index.js';\nimport type { TTS, TTSError } from '../tts/tts.js';\nimport {\n  DEFAULT_API_CONNECT_OPTIONS,\n  DEFAULT_SESSION_CONNECT_OPTIONS,\n  type ResolvedSessionConnectOptions,\n  type SessionConnectOptions,\n} from '../types.js';\nimport type { VAD } from '../vad.js';\nimport type { Agent } from './agent.js';\nimport { AgentActivity } from './agent_activity.js';\nimport type { _TurnDetector } from './audio_recognition.js';\nimport {\n  type AgentEvent,\n  AgentSessionEventTypes,\n  type AgentState,\n  type AgentStateChangedEvent,\n  type CloseEvent,\n  CloseReason,\n  type ConversationItemAddedEvent,\n  type ErrorEvent,\n  type FunctionToolsExecutedEvent,\n  type MetricsCollectedEvent,\n  type ShutdownReason,\n  type SpeechCreatedEvent,\n  type UserInputTranscribedEvent,\n  type UserState,\n  type UserStateChangedEvent,\n  createAgentStateChangedEvent,\n  createCloseEvent,\n  createConversationItemAddedEvent,\n  createUserStateChangedEvent,\n} from './events.js';\nimport { AgentInput, AgentOutput } from './io.js';\nimport { RecorderIO } from './recorder_io/index.js';\nimport { RoomIO, type RoomInputOptions, type RoomOutputOptions } from './room_io/index.js';\nimport type { UnknownUserData } from './run_context.js';\nimport type { SpeechHandle } from './speech_handle.js';\nimport { RunResult } from './testing/run_result.js';\n\nexport interface VoiceOptions {\n  allowInterruptions: boolean;\n  discardAudioIfUninterruptible: boolean;\n  minInterruptionDuration: number;\n  minInterruptionWords: number;\n  minEndpointingDelay: number;\n  maxEndpointingDelay: number;\n  maxToolSteps: number;\n  preemptiveGeneration: boolean;\n  userAwayTimeout?: number | null;\n}\n\nconst defaultVoiceOptions: VoiceOptions = {\n  allowInterruptions: true,\n  discardAudioIfUninterruptible: true,\n  minInterruptionDuration: 500,\n  minInterruptionWords: 0,\n  minEndpointingDelay: 500,\n  maxEndpointingDelay: 6000,\n  maxToolSteps: 3,\n  preemptiveGeneration: false,\n  userAwayTimeout: 15.0,\n} as const;\n\nexport type TurnDetectionMode = 'stt' | 'vad' | 'realtime_llm' | 'manual' | _TurnDetector;\n\nexport type AgentSessionCallbacks = {\n  [AgentSessionEventTypes.UserInputTranscribed]: (ev: UserInputTranscribedEvent) => void;\n  [AgentSessionEventTypes.AgentStateChanged]: (ev: AgentStateChangedEvent) => void;\n  [AgentSessionEventTypes.UserStateChanged]: (ev: UserStateChangedEvent) => void;\n  [AgentSessionEventTypes.ConversationItemAdded]: (ev: ConversationItemAddedEvent) => void;\n  [AgentSessionEventTypes.FunctionToolsExecuted]: (ev: FunctionToolsExecutedEvent) => void;\n  [AgentSessionEventTypes.MetricsCollected]: (ev: MetricsCollectedEvent) => void;\n  [AgentSessionEventTypes.SpeechCreated]: (ev: SpeechCreatedEvent) => void;\n  [AgentSessionEventTypes.Error]: (ev: ErrorEvent) => void;\n  [AgentSessionEventTypes.Close]: (ev: CloseEvent) => void;\n};\n\nexport type AgentSessionOptions<UserData = UnknownUserData> = {\n  turnDetection?: TurnDetectionMode;\n  stt?: STT | STTModelString;\n  vad?: VAD;\n  llm?: LLM | RealtimeModel | LLMModels;\n  tts?: TTS | TTSModelString;\n  userData?: UserData;\n  voiceOptions?: Partial<VoiceOptions>;\n  connOptions?: SessionConnectOptions;\n};\n\nexport class AgentSession<\n  UserData = UnknownUserData,\n> extends (EventEmitter as new () => TypedEmitter<AgentSessionCallbacks>) {\n  vad?: VAD;\n  stt?: STT;\n  llm?: LLM | RealtimeModel;\n  tts?: TTS;\n  turnDetection?: TurnDetectionMode;\n\n  readonly options: VoiceOptions;\n\n  private agent?: Agent;\n  private activity?: AgentActivity;\n  private nextActivity?: AgentActivity;\n  private started = false;\n  private userState: UserState = 'listening';\n\n  private roomIO?: RoomIO;\n  private logger = log();\n\n  private _chatCtx: ChatContext;\n  private _userData: UserData | undefined;\n  private _agentState: AgentState = 'initializing';\n\n  private _input: AgentInput;\n  private _output: AgentOutput;\n\n  private closingTask: Promise<void> | null = null;\n  private userAwayTimer: NodeJS.Timeout | null = null;\n\n  // Connection options for STT, LLM, and TTS\n  private _connOptions: ResolvedSessionConnectOptions;\n\n  // Unrecoverable error counts, reset after agent speaking\n  private llmErrorCounts = 0;\n  private ttsErrorCounts = 0;\n\n  private sessionSpan?: Span;\n  private userSpeakingSpan?: Span;\n  private agentSpeakingSpan?: Span;\n\n  /** @internal */\n  _recorderIO?: RecorderIO;\n\n  /** @internal */\n  rootSpanContext?: Context;\n\n  /** @internal */\n  _recordedEvents: AgentEvent[] = [];\n\n  /** @internal */\n  _enableRecording = false;\n\n  /** @internal - Timestamp when the session started (milliseconds) */\n  _startedAt?: number;\n\n  /** @internal - Current run state for testing */\n  _globalRunState?: RunResult;\n\n  constructor(opts: AgentSessionOptions<UserData>) {\n    super();\n\n    const {\n      vad,\n      stt,\n      llm,\n      tts,\n      turnDetection,\n      userData,\n      voiceOptions = defaultVoiceOptions,\n      connOptions,\n    } = opts;\n\n    // Merge user-provided connOptions with defaults\n    this._connOptions = {\n      sttConnOptions: { ...DEFAULT_API_CONNECT_OPTIONS, ...connOptions?.sttConnOptions },\n      llmConnOptions: { ...DEFAULT_API_CONNECT_OPTIONS, ...connOptions?.llmConnOptions },\n      ttsConnOptions: { ...DEFAULT_API_CONNECT_OPTIONS, ...connOptions?.ttsConnOptions },\n      maxUnrecoverableErrors:\n        connOptions?.maxUnrecoverableErrors ??\n        DEFAULT_SESSION_CONNECT_OPTIONS.maxUnrecoverableErrors,\n    };\n\n    this.vad = vad;\n\n    if (typeof stt === 'string') {\n      this.stt = InferenceSTT.fromModelString(stt);\n    } else {\n      this.stt = stt;\n    }\n\n    if (typeof llm === 'string') {\n      this.llm = InferenceLLM.fromModelString(llm);\n    } else {\n      this.llm = llm;\n    }\n\n    if (typeof tts === 'string') {\n      this.tts = InferenceTTS.fromModelString(tts);\n    } else {\n      this.tts = tts;\n    }\n\n    this.turnDetection = turnDetection;\n    this._userData = userData;\n\n    // configurable IO\n    this._input = new AgentInput(this.onAudioInputChanged);\n    this._output = new AgentOutput(this.onAudioOutputChanged, this.onTextOutputChanged);\n\n    // This is the \"global\" chat context, it holds the entire conversation history\n    this._chatCtx = ChatContext.empty();\n    this.options = { ...defaultVoiceOptions, ...voiceOptions };\n\n    this._onUserInputTranscribed = this._onUserInputTranscribed.bind(this);\n    this.on(AgentSessionEventTypes.UserInputTranscribed, this._onUserInputTranscribed);\n  }\n\n  emit<K extends keyof AgentSessionCallbacks>(\n    event: K,\n    ...args: Parameters<AgentSessionCallbacks[K]>\n  ): boolean {\n    const eventData = args[0] as AgentEvent;\n    this._recordedEvents.push(eventData);\n    return super.emit(event, ...args);\n  }\n\n  get input(): AgentInput {\n    return this._input;\n  }\n\n  get output(): AgentOutput {\n    return this._output;\n  }\n\n  get userData(): UserData {\n    if (this._userData === undefined) {\n      throw new Error('Voice agent userData is not set');\n    }\n\n    return this._userData;\n  }\n\n  get history(): ChatContext {\n    return this._chatCtx;\n  }\n\n  /** Connection options for STT, LLM, and TTS. */\n  get connOptions(): ResolvedSessionConnectOptions {\n    return this._connOptions;\n  }\n\n  set userData(value: UserData) {\n    this._userData = value;\n  }\n\n  private async _startImpl({\n    agent,\n    room,\n    inputOptions,\n    outputOptions,\n    span,\n  }: {\n    agent: Agent;\n    room?: Room;\n    inputOptions?: Partial<RoomInputOptions>;\n    outputOptions?: Partial<RoomOutputOptions>;\n    span: Span;\n  }): Promise<void> {\n    span.setAttribute(traceTypes.ATTR_AGENT_LABEL, agent.id);\n\n    this.agent = agent;\n    this._updateAgentState('initializing');\n\n    const tasks: Promise<void>[] = [];\n\n    if (room && !this.roomIO) {\n      // Check for existing input/output configuration and warn if needed\n      if (this.input.audio && inputOptions?.audioEnabled !== false) {\n        this.logger.warn(\n          'RoomIO audio input is enabled but input.audio is already set, ignoring..',\n        );\n      }\n\n      if (this.output.audio && outputOptions?.audioEnabled !== false) {\n        this.logger.warn(\n          'RoomIO audio output is enabled but output.audio is already set, ignoring..',\n        );\n      }\n\n      if (this.output.transcription && outputOptions?.transcriptionEnabled !== false) {\n        this.logger.warn(\n          'RoomIO transcription output is enabled but output.transcription is already set, ignoring..',\n        );\n      }\n\n      this.roomIO = new RoomIO({\n        agentSession: this,\n        room,\n        inputOptions,\n        outputOptions,\n      });\n      this.roomIO.start();\n    }\n\n    let ctx: JobContext | undefined = undefined;\n    try {\n      ctx = getJobContext();\n    } catch {\n      // JobContext is not available in evals\n    }\n\n    if (ctx) {\n      if (room && ctx.room === room && !room.isConnected) {\n        this.logger.debug('Auto-connecting to room via job context');\n        tasks.push(ctx.connect());\n      }\n\n      if (ctx._primaryAgentSession === undefined) {\n        ctx._primaryAgentSession = this;\n      } else if (this._enableRecording) {\n        throw new Error(\n          'Only one `AgentSession` can be the primary at a time. If you want to ignore primary designation, use `session.start({ record: false })`.',\n        );\n      }\n\n      if (this.input.audio && this.output.audio && this._enableRecording) {\n        this._recorderIO = new RecorderIO({ agentSession: this });\n        this.input.audio = this._recorderIO.recordInput(this.input.audio);\n        this.output.audio = this._recorderIO.recordOutput(this.output.audio);\n\n        // Start recording to session directory\n        const sessionDir = ctx.sessionDirectory;\n        if (sessionDir) {\n          tasks.push(this._recorderIO.start(`${sessionDir}/audio.ogg`));\n        }\n      }\n    }\n\n    // TODO(AJS-265): add shutdown callback to job context\n    tasks.push(this.updateActivity(this.agent));\n\n    await Promise.allSettled(tasks);\n\n    // Log used IO configuration\n    this.logger.debug(\n      `using audio io: ${this.input.audio ? '`' + this.input.audio.constructor.name + '`' : '(none)'} -> \\`AgentSession\\` -> ${this.output.audio ? '`' + this.output.audio.constructor.name + '`' : '(none)'}`,\n    );\n\n    this.logger.debug(\n      `using transcript io: \\`AgentSession\\` -> ${this.output.transcription ? '`' + this.output.transcription.constructor.name + '`' : '(none)'}`,\n    );\n\n    this.started = true;\n    this._startedAt = Date.now();\n    this._updateAgentState('listening');\n  }\n\n  async start({\n    agent,\n    room,\n    inputOptions,\n    outputOptions,\n    record,\n  }: {\n    agent: Agent;\n    room?: Room;\n    inputOptions?: Partial<RoomInputOptions>;\n    outputOptions?: Partial<RoomOutputOptions>;\n    record?: boolean;\n  }): Promise<void> {\n    if (this.started) {\n      return;\n    }\n\n    let ctx: JobContext | undefined = undefined;\n    try {\n      ctx = getJobContext();\n\n      if (record === undefined) {\n        record = ctx.job.enableRecording;\n      }\n\n      this._enableRecording = record;\n\n      if (this._enableRecording) {\n        ctx.initRecording();\n      }\n    } catch (error) {\n      // JobContext is not available in evals\n      this.logger.warn('JobContext is not available');\n    }\n\n    this.sessionSpan = tracer.startSpan({\n      name: 'agent_session',\n      context: ROOT_CONTEXT,\n    });\n\n    this.rootSpanContext = trace.setSpan(ROOT_CONTEXT, this.sessionSpan);\n\n    await this._startImpl({\n      agent,\n      room,\n      inputOptions,\n      outputOptions,\n      span: this.sessionSpan,\n    });\n  }\n\n  updateAgent(agent: Agent): void {\n    this.agent = agent;\n\n    if (this.started) {\n      this.updateActivity(agent);\n    }\n  }\n\n  commitUserTurn() {\n    if (!this.activity) {\n      throw new Error('AgentSession is not running');\n    }\n\n    this.activity.commitUserTurn();\n  }\n\n  clearUserTurn() {\n    if (!this.activity) {\n      throw new Error('AgentSession is not running');\n    }\n    this.activity.clearUserTurn();\n  }\n\n  say(\n    text: string | ReadableStream<string>,\n    options?: {\n      audio?: ReadableStream<AudioFrame>;\n      allowInterruptions?: boolean;\n      addToChatCtx?: boolean;\n    },\n  ): SpeechHandle {\n    if (!this.activity) {\n      throw new Error('AgentSession is not running');\n    }\n\n    const doSay = (activity: AgentActivity) => {\n      return activity.say(text, options);\n    };\n\n    // attach to the session span if called outside of the AgentSession\n    const activeSpan = trace.getActiveSpan();\n    if (!activeSpan && this.rootSpanContext) {\n      return otelContext.with(this.rootSpanContext, () => doSay(this.activity!));\n    }\n\n    return doSay(this.activity);\n  }\n\n  interrupt() {\n    if (!this.activity) {\n      throw new Error('AgentSession is not running');\n    }\n    return this.activity.interrupt();\n  }\n\n  generateReply(options?: {\n    userInput?: string;\n    instructions?: string;\n    toolChoice?: ToolChoice;\n    allowInterruptions?: boolean;\n  }): SpeechHandle {\n    if (!this.activity) {\n      throw new Error('AgentSession is not running');\n    }\n\n    const userMessage = options?.userInput\n      ? new ChatMessage({\n          role: 'user',\n          content: options.userInput,\n        })\n      : undefined;\n\n    const doGenerateReply = (activity: AgentActivity, nextActivity?: AgentActivity) => {\n      if (activity.draining) {\n        if (!nextActivity) {\n          throw new Error('AgentSession is closing, cannot use generateReply()');\n        }\n        return nextActivity.generateReply({ userMessage, ...options });\n      }\n      return activity.generateReply({ userMessage, ...options });\n    };\n\n    // attach to the session span if called outside of the AgentSession\n    const activeSpan = trace.getActiveSpan();\n    let handle: SpeechHandle;\n    if (!activeSpan && this.rootSpanContext) {\n      handle = otelContext.with(this.rootSpanContext, () =>\n        doGenerateReply(this.activity!, this.nextActivity),\n      );\n    } else {\n      handle = doGenerateReply(this.activity!, this.nextActivity);\n    }\n\n    if (this._globalRunState) {\n      this._globalRunState._watchHandle(handle);\n    }\n\n    return handle;\n  }\n\n  /**\n   * Run a test with user input and return a result for assertions.\n   *\n   * This method is primarily used for testing agent behavior without\n   * requiring a real room connection.\n   *\n   * @example\n   * ```typescript\n   * const result = await session.run({ userInput: 'Hello' });\n   * result.expect.nextEvent().isMessage({ role: 'assistant' });\n   * result.expect.noMoreEvents();\n   * ```\n   *\n   * @param options - Run options including user input\n   * @returns A RunResult that resolves when the agent finishes responding\n   *\n   * TODO: Add outputType parameter for typed outputs (parity with Python)\n   */\n  run(options: { userInput: string }): RunResult {\n    if (this._globalRunState && !this._globalRunState.done()) {\n      throw new Error('nested runs are not supported');\n    }\n\n    const runState = new RunResult({ userInput: options.userInput });\n    this._globalRunState = runState;\n    this.generateReply({ userInput: options.userInput });\n\n    return runState;\n  }\n\n  private async updateActivity(agent: Agent): Promise<void> {\n    const runWithContext = async () => {\n      // TODO(AJS-129): add lock to agent activity core lifecycle\n      this.nextActivity = new AgentActivity(agent, this);\n\n      const previousActivity = this.activity;\n\n      if (this.activity) {\n        await this.activity.drain();\n        await this.activity.close();\n      }\n\n      this.activity = this.nextActivity;\n      this.nextActivity = undefined;\n\n      this._chatCtx.insert(\n        new AgentHandoffItem({\n          oldAgentId: previousActivity?.agent.id,\n          newAgentId: agent.id,\n        }),\n      );\n      this.logger.debug(\n        { previousAgentId: previousActivity?.agent.id, newAgentId: agent.id },\n        'Agent handoff inserted into chat context',\n      );\n\n      await this.activity.start();\n\n      if (this._input.audio) {\n        this.activity.attachAudioInput(this._input.audio.stream);\n      }\n    };\n\n    // Run within session span context if available\n    if (this.rootSpanContext) {\n      return otelContext.with(this.rootSpanContext, runWithContext);\n    }\n\n    return runWithContext();\n  }\n\n  get chatCtx(): ChatContext {\n    return this._chatCtx.copy();\n  }\n\n  get agentState(): AgentState {\n    return this._agentState;\n  }\n\n  get currentAgent(): Agent {\n    if (!this.agent) {\n      throw new Error('AgentSession is not running');\n    }\n\n    return this.agent;\n  }\n\n  async close(): Promise<void> {\n    await this.closeImpl(CloseReason.USER_INITIATED);\n  }\n\n  shutdown(options?: { drain?: boolean; reason?: ShutdownReason }): void {\n    const { drain = true, reason = CloseReason.USER_INITIATED } = options ?? {};\n\n    this._closeSoon({\n      reason,\n      drain,\n    });\n  }\n\n  /** @internal */\n  _closeSoon({\n    reason,\n    drain = false,\n    error = null,\n  }: {\n    reason: ShutdownReason;\n    drain?: boolean;\n    error?: RealtimeModelError | STTError | TTSError | LLMError | null;\n  }): void {\n    if (this.closingTask) {\n      return;\n    }\n    this.closeImpl(reason, error, drain);\n  }\n\n  /** @internal */\n  _onError(error: RealtimeModelError | STTError | TTSError | LLMError): void {\n    if (this.closingTask || error.recoverable) {\n      return;\n    }\n\n    // Track error counts per type to implement max_unrecoverable_errors logic\n    if (error.type === 'llm_error') {\n      this.llmErrorCounts += 1;\n      if (this.llmErrorCounts <= this._connOptions.maxUnrecoverableErrors) {\n        return;\n      }\n    } else if (error.type === 'tts_error') {\n      this.ttsErrorCounts += 1;\n      if (this.ttsErrorCounts <= this._connOptions.maxUnrecoverableErrors) {\n        return;\n      }\n    }\n\n    this.logger.error(error, 'AgentSession is closing due to unrecoverable error');\n\n    this.closingTask = (async () => {\n      await this.closeImpl(CloseReason.ERROR, error);\n    })().then(() => {\n      this.closingTask = null;\n    });\n  }\n\n  /** @internal */\n  _conversationItemAdded(item: ChatMessage): void {\n    this._chatCtx.insert(item);\n    this.emit(AgentSessionEventTypes.ConversationItemAdded, createConversationItemAddedEvent(item));\n  }\n\n  /** @internal */\n  _toolItemsAdded(items: (FunctionCall | FunctionCallOutput)[]): void {\n    this._chatCtx.insert(items);\n  }\n\n  /** @internal */\n  _updateAgentState(state: AgentState) {\n    if (this._agentState === state) {\n      return;\n    }\n\n    if (state === 'speaking') {\n      // Reset error counts when agent starts speaking\n      this.llmErrorCounts = 0;\n      this.ttsErrorCounts = 0;\n\n      if (this.agentSpeakingSpan === undefined) {\n        this.agentSpeakingSpan = tracer.startSpan({\n          name: 'agent_speaking',\n          context: this.rootSpanContext,\n        });\n\n        // TODO(brian): PR4 - Set participant attributes if roomIO.room.localParticipant is available\n        // (Ref: Python agent_session.py line 1161-1164)\n      }\n    } else if (this.agentSpeakingSpan !== undefined) {\n      // TODO(brian): PR4 - Set ATTR_END_TIME attribute if available\n      this.agentSpeakingSpan.end();\n      this.agentSpeakingSpan = undefined;\n    }\n\n    const oldState = this._agentState;\n    this._agentState = state;\n\n    // Handle user away timer based on state changes\n    if (state === 'listening' && this.userState === 'listening') {\n      this._setUserAwayTimer();\n    } else {\n      this._cancelUserAwayTimer();\n    }\n\n    this.emit(\n      AgentSessionEventTypes.AgentStateChanged,\n      createAgentStateChangedEvent(oldState, state),\n    );\n  }\n\n  /** @internal */\n  _updateUserState(state: UserState, _lastSpeakingTime?: number) {\n    if (this.userState === state) {\n      return;\n    }\n\n    if (state === 'speaking' && this.userSpeakingSpan === undefined) {\n      this.userSpeakingSpan = tracer.startSpan({\n        name: 'user_speaking',\n        context: this.rootSpanContext,\n      });\n\n      // TODO(brian): PR4 - Set participant attributes if roomIO.linkedParticipant is available\n      // (Ref: Python agent_session.py line 1192-1195)\n    } else if (this.userSpeakingSpan !== undefined) {\n      // TODO(brian): PR4 - Set ATTR_END_TIME attribute with lastSpeakingTime if available\n      this.userSpeakingSpan.end();\n      this.userSpeakingSpan = undefined;\n    }\n\n    const oldState = this.userState;\n    this.userState = state;\n\n    // Handle user away timer based on state changes\n    if (state === 'listening' && this._agentState === 'listening') {\n      this._setUserAwayTimer();\n    } else {\n      this._cancelUserAwayTimer();\n    }\n\n    this.emit(\n      AgentSessionEventTypes.UserStateChanged,\n      createUserStateChangedEvent(oldState, state),\n    );\n  }\n\n  // -- User changed input/output streams/sinks --\n  private onAudioInputChanged(): void {\n    if (!this.started) {\n      return;\n    }\n\n    if (this.activity && this._input.audio) {\n      this.activity.attachAudioInput(this._input.audio.stream);\n    }\n  }\n\n  private onAudioOutputChanged(): void {}\n\n  private onTextOutputChanged(): void {}\n\n  private _setUserAwayTimer(): void {\n    this._cancelUserAwayTimer();\n\n    if (this.options.userAwayTimeout === null || this.options.userAwayTimeout === undefined) {\n      return;\n    }\n\n    if (this.roomIO && !this.roomIO.isParticipantAvailable) {\n      return;\n    }\n\n    this.userAwayTimer = setTimeout(() => {\n      this.logger.debug('User away timeout triggered');\n      this._updateUserState('away');\n    }, this.options.userAwayTimeout * 1000);\n  }\n\n  private _cancelUserAwayTimer(): void {\n    if (this.userAwayTimer !== null) {\n      clearTimeout(this.userAwayTimer);\n      this.userAwayTimer = null;\n    }\n  }\n\n  private _onUserInputTranscribed(ev: UserInputTranscribedEvent): void {\n    if (this.userState === 'away' && ev.isFinal) {\n      this.logger.debug('User returned from away state due to speech input');\n      this._updateUserState('listening');\n    }\n  }\n\n  private async closeImpl(\n    reason: ShutdownReason,\n    error: RealtimeModelError | LLMError | TTSError | STTError | null = null,\n    drain: boolean = false,\n  ): Promise<void> {\n    if (this.rootSpanContext) {\n      return otelContext.with(this.rootSpanContext, async () => {\n        await this.closeImplInner(reason, error, drain);\n      });\n    }\n\n    return this.closeImplInner(reason, error, drain);\n  }\n\n  private async closeImplInner(\n    reason: ShutdownReason,\n    error: RealtimeModelError | LLMError | TTSError | STTError | null = null,\n    drain: boolean = false,\n  ): Promise<void> {\n    if (!this.started) {\n      return;\n    }\n\n    this._cancelUserAwayTimer();\n    this.off(AgentSessionEventTypes.UserInputTranscribed, this._onUserInputTranscribed);\n\n    if (this.activity) {\n      if (!drain) {\n        try {\n          this.activity.interrupt();\n        } catch (error) {\n          // TODO(shubhra): force interrupt or wait for it to finish?\n          // it might be an audio played from the error callback\n        }\n      }\n      await this.activity.drain();\n      // wait any uninterruptible speech to finish\n      await this.activity.currentSpeech?.waitForPlayout();\n      try {\n        this.activity.detachAudioInput();\n      } catch (error) {\n        // Ignore detach errors during cleanup - source may not have been set\n      }\n    }\n\n    // Close recorder before detaching inputs/outputs (keep reference for session report)\n    if (this._recorderIO) {\n      await this._recorderIO.close();\n    }\n\n    // detach the inputs and outputs\n    this.input.audio = null;\n    this.output.audio = null;\n    this.output.transcription = null;\n\n    await this.roomIO?.close();\n    this.roomIO = undefined;\n\n    await this.activity?.close();\n    this.activity = undefined;\n\n    if (this.sessionSpan) {\n      this.sessionSpan.end();\n      this.sessionSpan = undefined;\n    }\n\n    if (this.userSpeakingSpan) {\n      this.userSpeakingSpan.end();\n      this.userSpeakingSpan = undefined;\n    }\n\n    if (this.agentSpeakingSpan) {\n      this.agentSpeakingSpan.end();\n      this.agentSpeakingSpan = undefined;\n    }\n\n    this.started = false;\n\n    this.emit(AgentSessionEventTypes.Close, createCloseEvent(reason, error));\n\n    this.userState = 'listening';\n    this._agentState = 'initializing';\n    this.rootSpanContext = undefined;\n    this.llmErrorCounts = 0;\n    this.ttsErrorCounts = 0;\n\n    this.logger.info({ reason, error }, 'AgentSession closed');\n  }\n}\n"],"mappings":"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","names":["error"]}