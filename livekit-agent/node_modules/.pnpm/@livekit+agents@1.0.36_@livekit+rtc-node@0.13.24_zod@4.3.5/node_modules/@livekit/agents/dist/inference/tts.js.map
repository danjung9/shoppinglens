{"version":3,"sources":["../../src/inference/tts.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2025 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { AudioFrame } from '@livekit/rtc-node';\nimport { WebSocket } from 'ws';\nimport { APIError, APIStatusError } from '../_exceptions.js';\nimport { AudioByteStream } from '../audio.js';\nimport { ConnectionPool } from '../connection_pool.js';\nimport { log } from '../log.js';\nimport { createStreamChannel } from '../stream/stream_channel.js';\nimport { basic as tokenizeBasic } from '../tokenize/index.js';\nimport type { ChunkedStream } from '../tts/index.js';\nimport { SynthesizeStream as BaseSynthesizeStream, TTS as BaseTTS } from '../tts/index.js';\nimport { type APIConnectOptions, DEFAULT_API_CONNECT_OPTIONS } from '../types.js';\nimport { Event, Future, Task, cancelAndWait, combineSignals, shortuuid } from '../utils.js';\nimport {\n  type TtsClientEvent,\n  type TtsServerEvent,\n  type TtsSessionCreateEvent,\n  ttsClientEventSchema,\n  ttsServerEventSchema,\n} from './api_protos.js';\nimport { type AnyString, connectWs, createAccessToken } from './utils.js';\n\nexport type CartesiaModels =\n  | 'cartesia'\n  | 'cartesia/sonic'\n  | 'cartesia/sonic-2'\n  | 'cartesia/sonic-turbo';\n\nexport type ElevenlabsModels =\n  | 'elevenlabs'\n  | 'elevenlabs/eleven_flash_v2'\n  | 'elevenlabs/eleven_flash_v2_5'\n  | 'elevenlabs/eleven_turbo_v2'\n  | 'elevenlabs/eleven_turbo_v2_5'\n  | 'elevenlabs/eleven_multilingual_v2';\n\nexport type RimeModels = 'rime' | 'rime/mist' | 'rime/mistv2' | 'rime/arcana';\n\nexport type InworldModels = 'inworld' | 'inworld/inworld-tts-1';\n\nexport interface CartesiaOptions {\n  duration?: number; // max duration of audio in seconds\n  speed?: 'slow' | 'normal' | 'fast'; // default: not specified\n}\n\nexport interface ElevenlabsOptions {\n  inactivity_timeout?: number; // default: 60\n  apply_text_normalization?: 'auto' | 'off' | 'on'; // default: \"auto\"\n}\n\nexport interface RimeOptions {}\n\nexport interface InworldOptions {}\n\ntype _TTSModels = CartesiaModels | ElevenlabsModels | RimeModels | InworldModels;\n\nexport type TTSModels = CartesiaModels | ElevenlabsModels | RimeModels | InworldModels | AnyString;\n\nexport type ModelWithVoice = `${_TTSModels}:${string}` | TTSModels;\n\nexport type TTSOptions<TModel extends TTSModels> = TModel extends CartesiaModels\n  ? CartesiaOptions\n  : TModel extends ElevenlabsModels\n    ? ElevenlabsOptions\n    : TModel extends RimeOptions\n      ? RimeOptions\n      : TModel extends InworldOptions\n        ? InworldOptions\n        : Record<string, unknown>;\n\ntype TTSEncoding = 'pcm_s16le';\n\nconst DEFAULT_ENCODING: TTSEncoding = 'pcm_s16le';\nconst DEFAULT_SAMPLE_RATE = 16000;\nconst DEFAULT_BASE_URL = 'https://agent-gateway.livekit.cloud/v1';\nconst NUM_CHANNELS = 1;\nconst DEFAULT_LANGUAGE = 'en';\n\nexport interface InferenceTTSOptions<TModel extends TTSModels> {\n  model?: TModel;\n  voice?: string;\n  language?: string;\n  encoding: TTSEncoding;\n  sampleRate: number;\n  baseURL: string;\n  apiKey: string;\n  apiSecret: string;\n  modelOptions: TTSOptions<TModel>;\n}\n\n/**\n * Livekit Cloud Inference TTS\n */\nexport class TTS<TModel extends TTSModels> extends BaseTTS {\n  private opts: InferenceTTSOptions<TModel>;\n  private streams: Set<SynthesizeStream<TModel>> = new Set();\n  pool: ConnectionPool<WebSocket>;\n\n  #logger = log();\n\n  constructor(opts: {\n    model: TModel;\n    voice?: string;\n    language?: string;\n    baseURL?: string;\n    encoding?: TTSEncoding;\n    sampleRate?: number;\n    apiKey?: string;\n    apiSecret?: string;\n    modelOptions?: TTSOptions<TModel>;\n  }) {\n    const sampleRate = opts?.sampleRate ?? DEFAULT_SAMPLE_RATE;\n    super(sampleRate, 1, { streaming: true });\n\n    const {\n      model,\n      voice,\n      language = DEFAULT_LANGUAGE,\n      baseURL,\n      encoding = DEFAULT_ENCODING,\n      apiKey,\n      apiSecret,\n      modelOptions = {} as TTSOptions<TModel>,\n    } = opts || {};\n\n    const lkBaseURL = baseURL || process.env.LIVEKIT_INFERENCE_URL || DEFAULT_BASE_URL;\n    const lkApiKey = apiKey || process.env.LIVEKIT_INFERENCE_API_KEY || process.env.LIVEKIT_API_KEY;\n    if (!lkApiKey) {\n      throw new Error('apiKey is required: pass apiKey or set LIVEKIT_API_KEY');\n    }\n\n    const lkApiSecret =\n      apiSecret || process.env.LIVEKIT_INFERENCE_API_SECRET || process.env.LIVEKIT_API_SECRET;\n    if (!lkApiSecret) {\n      throw new Error('apiSecret is required: pass apiSecret or set LIVEKIT_API_SECRET');\n    }\n\n    // read voice id from the model if provided: \"provider/model:voice_id\"\n    let nextModel = model;\n    let nextVoice = voice;\n    if (typeof nextModel === 'string') {\n      const idx = nextModel.lastIndexOf(':');\n      if (idx !== -1) {\n        const voiceFromModel = nextModel.slice(idx + 1);\n        if (nextVoice && nextVoice !== voiceFromModel) {\n          this.#logger.warn(\n            '`voice` is provided via both argument and model, using the one from the argument',\n            { voice: nextVoice, model: nextModel },\n          );\n        } else {\n          nextVoice = voiceFromModel;\n        }\n        nextModel = nextModel.slice(0, idx) as TModel;\n      }\n    }\n\n    this.opts = {\n      model: nextModel,\n      voice: nextVoice,\n      language,\n      encoding,\n      sampleRate,\n      baseURL: lkBaseURL,\n      apiKey: lkApiKey,\n      apiSecret: lkApiSecret,\n      modelOptions,\n    };\n\n    // Initialize connection pool\n    this.pool = new ConnectionPool<WebSocket>({\n      connectCb: (timeout) => this.connectWs(timeout),\n      closeCb: (ws) => this.closeWs(ws),\n      maxSessionDuration: 300_000,\n      markRefreshedOnGet: true,\n      connectTimeout: 10_000, // 10 seconds default\n    });\n  }\n\n  get label() {\n    return 'inference.TTS';\n  }\n\n  static fromModelString(modelString: string): TTS<AnyString> {\n    if (modelString.includes(':')) {\n      const [model, voice] = modelString.split(':') as [TTSModels, string];\n      return new TTS({ model, voice });\n    }\n    return new TTS({ model: modelString });\n  }\n\n  updateOptions(opts: Partial<Pick<InferenceTTSOptions<TModel>, 'model' | 'voice' | 'language'>>) {\n    this.opts = { ...this.opts, ...opts };\n    for (const stream of this.streams) {\n      stream.updateOptions(opts);\n    }\n  }\n\n  synthesize(_: string): ChunkedStream {\n    throw new Error('ChunkedStream is not implemented');\n  }\n\n  stream(options?: { connOptions?: APIConnectOptions }): SynthesizeStream<TModel> {\n    const { connOptions = DEFAULT_API_CONNECT_OPTIONS } = options || {};\n    const stream = new SynthesizeStream(this, { ...this.opts }, connOptions);\n    this.streams.add(stream);\n    return stream;\n  }\n\n  async connectWs(timeout: number): Promise<WebSocket> {\n    let baseURL = this.opts.baseURL;\n    if (baseURL.startsWith('http://') || baseURL.startsWith('https://')) {\n      baseURL = baseURL.replace('http', 'ws');\n    }\n\n    const token = await createAccessToken(this.opts.apiKey, this.opts.apiSecret);\n    const url = `${baseURL}/tts`;\n    const headers = { Authorization: `Bearer ${token}` } as Record<string, string>;\n\n    const params = {\n      type: 'session.create',\n      sample_rate: String(this.opts.sampleRate),\n      encoding: this.opts.encoding,\n      extra: this.opts.modelOptions,\n    } as TtsSessionCreateEvent;\n\n    if (this.opts.voice) params.voice = this.opts.voice;\n    if (this.opts.model) params.model = this.opts.model;\n    if (this.opts.language) params.language = this.opts.language;\n\n    this.#logger.debug({ url }, 'inference.TTS creating new websocket connection (pool miss)');\n    const socket = await connectWs(url, headers, timeout);\n    socket.send(JSON.stringify(params));\n    return socket;\n  }\n\n  async closeWs(ws: WebSocket) {\n    await ws.close();\n  }\n\n  prewarm(): void {\n    this.pool.prewarm();\n  }\n\n  async close() {\n    for (const stream of this.streams) {\n      await stream.close();\n    }\n    this.streams.clear();\n    await this.pool.close();\n  }\n}\n\nexport class SynthesizeStream<TModel extends TTSModels> extends BaseSynthesizeStream {\n  private opts: InferenceTTSOptions<TModel>;\n  private tts: TTS<TModel>;\n\n  #logger = log();\n\n  constructor(tts: TTS<TModel>, opts: InferenceTTSOptions<TModel>, connOptions: APIConnectOptions) {\n    super(tts, connOptions);\n    this.opts = opts;\n    this.tts = tts;\n  }\n\n  get label() {\n    return 'inference.SynthesizeStream';\n  }\n\n  updateOptions(opts: Partial<Pick<InferenceTTSOptions<TModel>, 'model' | 'voice' | 'language'>>) {\n    this.opts = { ...this.opts, ...opts };\n  }\n\n  protected async run(): Promise<void> {\n    let closing = false;\n    let lastFrame: AudioFrame | undefined;\n\n    const sendTokenizerStream = new tokenizeBasic.SentenceTokenizer().stream();\n    const eventChannel = createStreamChannel<TtsServerEvent>();\n    const requestId = shortuuid('tts_request_');\n    const inputSentEvent = new Event();\n\n    // Signal for protocol-driven completion (when 'done' message is received)\n    const completionFuture = new Future<void>();\n\n    const resourceCleanup = async () => {\n      if (closing) return;\n      closing = true;\n      sendTokenizerStream.close();\n      // close() returns a promise; don't leak it\n      await eventChannel.close();\n    };\n\n    const sendClientEvent = async (event: TtsClientEvent, ws: WebSocket, signal: AbortSignal) => {\n      // Don't send events to a closed WebSocket or aborted controller\n      if (signal.aborted || closing) return;\n\n      const validatedEvent = await ttsClientEventSchema.parseAsync(event);\n      if (ws.readyState !== WebSocket.OPEN) {\n        this.#logger.warn('Trying to send client TTS event to a closed WebSocket');\n        return;\n      }\n      ws.send(JSON.stringify(validatedEvent));\n    };\n\n    const sendLastFrame = (segmentId: string, final: boolean) => {\n      if (lastFrame) {\n        this.queue.put({ requestId, segmentId, frame: lastFrame, final });\n        lastFrame = undefined;\n      }\n    };\n\n    const createInputTask = async (signal: AbortSignal) => {\n      for await (const data of this.input) {\n        if (signal.aborted || closing) break;\n        if (data === SynthesizeStream.FLUSH_SENTINEL) {\n          sendTokenizerStream.flush();\n          continue;\n        }\n        sendTokenizerStream.pushText(data);\n      }\n      // Only call endInput if the stream hasn't been closed by cleanup\n      if (!closing) {\n        sendTokenizerStream.endInput();\n      }\n    };\n\n    const createSentenceStreamTask = async (ws: WebSocket, signal: AbortSignal) => {\n      for await (const ev of sendTokenizerStream) {\n        if (signal.aborted || closing) break;\n\n        await sendClientEvent(\n          {\n            type: 'input_transcript',\n            transcript: ev.token + ' ',\n          },\n          ws,\n          signal,\n        );\n        inputSentEvent.set();\n      }\n\n      await sendClientEvent({ type: 'session.flush' }, ws, signal);\n      // needed in case empty input is sent\n      inputSentEvent.set();\n    };\n\n    // Handles WebSocket message routing and error handling\n    // Completes based on protocol messages, NOT on ws.close()\n    const createWsListenerTask = async (ws: WebSocket, signal: AbortSignal) => {\n      const onMessage = (data: Buffer) => {\n        try {\n          const eventJson = JSON.parse(data.toString()) as Record<string, unknown>;\n          const validatedEvent = ttsServerEventSchema.parse(eventJson);\n          // writer.write returns a promise; avoid unhandled rejections if stream is closed\n          void eventChannel.write(validatedEvent).catch((error) => {\n            this.#logger.debug(\n              { error },\n              'Failed writing TTS event to stream channel (likely closed)',\n            );\n          });\n        } catch (e) {\n          this.#logger.error({ error: e }, 'Error parsing WebSocket message');\n        }\n      };\n\n      const onError = (e: Error) => {\n        this.#logger.error({ error: e }, 'WebSocket error');\n        void resourceCleanup();\n        try {\n          // If the ws is misbehaving, hard-stop it immediately to avoid buffering.\n          ws.terminate?.();\n        } catch {\n          // ignore\n        }\n        // Ensure this ws is not reused\n        this.tts.pool.remove(ws);\n        completionFuture.reject(e);\n      };\n\n      const onClose = () => {\n        // WebSocket closed unexpectedly (not by us)\n        if (!closing) {\n          this.#logger.error('WebSocket closed unexpectedly');\n          void resourceCleanup();\n          // Ensure this ws is not reused\n          this.tts.pool.remove(ws);\n          completionFuture.reject(\n            new APIStatusError({\n              message: 'Gateway connection closed unexpectedly',\n              options: { requestId },\n            }),\n          );\n        }\n      };\n\n      const onAbort = () => {\n        void resourceCleanup();\n        try {\n          // On interruption/abort, close the websocket immediately so the server stops streaming\n          // and the ws library doesn't buffer unread frames in memory.\n          ws.terminate?.();\n        } catch {\n          // ignore\n        }\n        this.tts.pool.remove(ws);\n        inputSentEvent.set();\n        completionFuture.resolve();\n      };\n\n      // Attach listeners\n      ws.on('message', onMessage);\n      ws.on('error', onError);\n      ws.on('close', onClose);\n      signal.addEventListener('abort', onAbort);\n\n      try {\n        // Wait for protocol-driven completion or error\n        await completionFuture.await;\n      } finally {\n        // IMPORTANT: Remove listeners so connection can be reused\n        ws.off('message', onMessage);\n        ws.off('error', onError);\n        ws.off('close', onClose);\n        signal.removeEventListener('abort', onAbort);\n      }\n    };\n\n    const createRecvTask = async (signal: AbortSignal) => {\n      let currentSessionId: string | null = null;\n\n      const bstream = new AudioByteStream(this.opts.sampleRate, NUM_CHANNELS);\n      const serverEventStream = eventChannel.stream();\n      const reader = serverEventStream.getReader();\n\n      try {\n        await inputSentEvent.wait();\n\n        while (!this.closed && !signal.aborted) {\n          const result = await reader.read();\n          if (signal.aborted) return;\n          if (result.done) return;\n\n          const serverEvent = result.value;\n          switch (serverEvent.type) {\n            case 'session.created':\n              currentSessionId = serverEvent.session_id;\n              break;\n            case 'output_audio':\n              const base64Data = new Int8Array(Buffer.from(serverEvent.audio, 'base64'));\n              for (const frame of bstream.write(base64Data.buffer)) {\n                sendLastFrame(currentSessionId!, false);\n                lastFrame = frame;\n              }\n              break;\n            case 'done':\n              for (const frame of bstream.flush()) {\n                sendLastFrame(currentSessionId!, false);\n                lastFrame = frame;\n              }\n              sendLastFrame(currentSessionId!, true);\n              this.queue.put(SynthesizeStream.END_OF_STREAM);\n              await resourceCleanup();\n              completionFuture.resolve();\n              return;\n            case 'session.closed':\n              await resourceCleanup();\n              completionFuture.resolve();\n              return;\n            case 'error':\n              this.#logger.error(\n                { serverEvent },\n                'Received error message from LiveKit TTS WebSocket',\n              );\n              await resourceCleanup();\n              completionFuture.reject(\n                new APIError(`LiveKit TTS returned error: ${serverEvent.message}`),\n              );\n              return;\n            default:\n              this.#logger.warn('Unexpected message %s', serverEvent);\n              break;\n          }\n        }\n      } finally {\n        reader.releaseLock();\n        try {\n          await serverEventStream.cancel();\n        } catch (e) {\n          this.#logger.debug('Error cancelling serverEventStream (may already be cancelled):', e);\n        }\n      }\n    };\n\n    try {\n      await this.tts.pool.withConnection(\n        async (ws: WebSocket) => {\n          try {\n            // IMPORTANT: don't cancel the stream's controller on normal completion,\n            // otherwise the pool will remove+close the ws and every run becomes a pool miss.\n            const runController = new AbortController();\n            const onStreamAbort = () => runController.abort(this.abortController.signal.reason);\n            this.abortController.signal.addEventListener('abort', onStreamAbort, { once: true });\n\n            const tasks = [\n              Task.from(\n                async (controller) => {\n                  const combined = combineSignals(runController.signal, controller.signal);\n                  await createInputTask(combined);\n                },\n                undefined,\n                'inference-tts-input',\n              ),\n              Task.from(\n                async (controller) => {\n                  const combined = combineSignals(runController.signal, controller.signal);\n                  await createSentenceStreamTask(ws, combined);\n                },\n                undefined,\n                'inference-tts-sentence',\n              ),\n              Task.from(\n                async (controller) => {\n                  const combined = combineSignals(runController.signal, controller.signal);\n                  await createWsListenerTask(ws, combined);\n                },\n                undefined,\n                'inference-tts-ws-listener',\n              ),\n              Task.from(\n                async (controller) => {\n                  const combined = combineSignals(runController.signal, controller.signal);\n                  await createRecvTask(combined);\n                },\n                undefined,\n                'inference-tts-recv',\n              ),\n            ];\n\n            try {\n              await Promise.all(tasks.map((t) => t.result));\n            } finally {\n              // Mirror python finally: unblock recv and cancel all tasks.\n              inputSentEvent.set();\n              await resourceCleanup();\n              await cancelAndWait(tasks, 5000);\n              this.abortController.signal.removeEventListener('abort', onStreamAbort);\n            }\n          } catch (e) {\n            // If aborted, don't throw - let cleanup handle it\n            if (e instanceof Error && e.name === 'AbortError') {\n              return;\n            }\n            throw e;\n          }\n        },\n        {\n          timeout: this.connOptions.timeoutMs,\n        },\n      );\n    } catch (e) {\n      // Handle connection errors\n      if (e instanceof Error && e.name === 'AbortError') {\n        // Abort is expected during normal shutdown\n        return;\n      }\n      throw e;\n    } finally {\n      // Ensure cleanup always runs (and don't leak the promise)\n      await resourceCleanup();\n    }\n  }\n}\n"],"mappings":"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","names":[]}